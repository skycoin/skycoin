{"version":3,"file":"rules.js","sourceRoot":"","sources":["../../../../../../modules/@angular/router-deprecated/src/rules/rules.ts"],"names":[],"mappings":"OAAO,EAAC,SAAS,EAAE,OAAO,EAAC,MAAM,uBAAuB;OACjD,EAAC,aAAa,EAAC,MAAM,6BAA6B;OAClD,EAAC,cAAc,EAAC,MAAM,0BAA0B;OAChD,EAAC,GAAG,EAAC,MAAM,6BAA6B;OAExC,EAAM,uBAAuB,EAAC,MAAM,eAAe;OACnD,EAAC,oBAAoB,EAAC,MAAM,gBAAgB;AAInD,6EAA6E;AAC7E;AAAkC,CAAC;AAEnC,+BAA+B,UAAU;IACvC,YAAmB,WAAiC,EAAS,SAAc,EACxD,YAAmB;QACpC,OAAO,CAAC;QAFS,gBAAW,GAAX,WAAW,CAAsB;QAAS,cAAS,GAAT,SAAS,CAAK;QACxD,iBAAY,GAAZ,YAAY,CAAO;IAEtC,CAAC;AACH,CAAC;AAED,mCAAmC,UAAU;IAC3C,YAAmB,UAAiB,EAAS,WAAW;QAAI,OAAO,CAAC;QAAjD,eAAU,GAAV,UAAU,CAAO;QAAS,gBAAW,GAAX,WAAW,CAAA;IAAa,CAAC;AACxE,CAAC;AAUD;IAGE,YAAoB,eAA0B,EAAS,UAAiB;QAApD,oBAAe,GAAf,eAAe,CAAW;QAAS,eAAU,GAAV,UAAU,CAAO;QACtE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;IACxC,CAAC;IAED,IAAI,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IACtD,IAAI,IAAI,CAAC,GAAG,IAAI,MAAM,IAAI,aAAa,CAAC,oDAAoD,CAAC,CAAC,CAAC,CAAC;IAEhG;;OAEG;IACH,SAAS,CAAC,gBAAqB;QAC7B,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/D,KAAK,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;QAC/E,CAAC;QACD,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;IAED,QAAQ,CAAC,MAA4B;QACnC,MAAM,IAAI,aAAa,CAAC,+BAA+B,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC;AAGD,wCAAwC;AACxC;IAOE,kFAAkF;IAElF,YAAoB,UAAqB,EAAS,OAAqB,EACnD,UAAkB;QADlB,eAAU,GAAV,UAAU,CAAW;QAAS,YAAO,GAAP,OAAO,CAAc;QACnD,eAAU,GAAV,UAAU,CAAQ;QAL9B,WAAM,GAAsC,IAAI,GAAG,EAAgC,CAAC;QAM1F,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC;QAC/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QACjC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;IAC3C,CAAC;IAED,IAAI,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IACjD,IAAI,IAAI,CAAC,GAAG,IAAI,MAAM,IAAI,aAAa,CAAC,iDAAiD,CAAC,CAAC,CAAC,CAAC;IAE7F,SAAS,CAAC,gBAAqB;QAC7B,IAAI,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;QACrD,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACjB,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,oBAAoB,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;YAChD,IAAI,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;YAC3F,MAAM,CAAC,IAAI,SAAS,CAAC,oBAAoB,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;QACtE,CAAC,CAAC,CAAC;IACL,CAAC;IAED,QAAQ,CAAC,MAA4B;QACnC,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QACpD,IAAI,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC;QAChC,IAAI,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC;QACpC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,uBAAuB,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,CAAC;IACnF,CAAC;IAED,2BAA2B,CAAC,MAA4B;QACtD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC;IAEO,eAAe,CAAC,OAAe,EAAE,SAAmB,EACpC,MAA4B;QAClD,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;YACxC,MAAM,IAAI,aAAa,CAAC,sDAAsD,CAAC,CAAC;QAClF,CAAC;QACD,IAAI,OAAO,GAAG,OAAO,GAAG,GAAG,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC;QACD,IAAI,WAAW,GACX,IAAI,oBAAoB,CAAC,OAAO,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EACjE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QACvF,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QAEtC,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;AACH,CAAC;AAAA","sourcesContent":["import {isPresent, isBlank} from '../../src/facade/lang';\nimport {BaseException} from '../../src/facade/exceptions';\nimport {PromiseWrapper} from '../../src/facade/promise';\nimport {Map} from '../../src/facade/collection';\nimport {RouteHandler} from './route_handlers/route_handler';\nimport {Url, convertUrlParamsToArray} from '../url_parser';\nimport {ComponentInstruction} from '../instruction';\nimport {RoutePath, GeneratedUrl} from './route_paths/route_path';\n\n\n// RouteMatch objects hold information about a match between a rule and a URL\nexport abstract class RouteMatch {}\n\nexport class PathMatch extends RouteMatch {\n  constructor(public instruction: ComponentInstruction, public remaining: Url,\n              public remainingAux: Url[]) {\n    super();\n  }\n}\n\nexport class RedirectMatch extends RouteMatch {\n  constructor(public redirectTo: any[], public specificity) { super(); }\n}\n\n// Rules are responsible for recognizing URL segments and generating instructions\nexport interface AbstractRule {\n  hash: string;\n  path: string;\n  recognize(beginningSegment: Url): Promise<RouteMatch>;\n  generate(params: {[key: string]: any}): ComponentInstruction;\n}\n\nexport class RedirectRule implements AbstractRule {\n  public hash: string;\n\n  constructor(private _pathRecognizer: RoutePath, public redirectTo: any[]) {\n    this.hash = this._pathRecognizer.hash;\n  }\n\n  get path() { return this._pathRecognizer.toString(); }\n  set path(val) { throw new BaseException('you cannot set the path of a RedirectRule directly'); }\n\n  /**\n   * Returns `null` or a `ParsedUrl` representing the new path to match\n   */\n  recognize(beginningSegment: Url): Promise<RouteMatch> {\n    var match = null;\n    if (isPresent(this._pathRecognizer.matchUrl(beginningSegment))) {\n      match = new RedirectMatch(this.redirectTo, this._pathRecognizer.specificity);\n    }\n    return PromiseWrapper.resolve(match);\n  }\n\n  generate(params: {[key: string]: any}): ComponentInstruction {\n    throw new BaseException(`Tried to generate a redirect.`);\n  }\n}\n\n\n// represents something like '/foo/:bar'\nexport class RouteRule implements AbstractRule {\n  specificity: string;\n  terminal: boolean;\n  hash: string;\n\n  private _cache: Map<string, ComponentInstruction> = new Map<string, ComponentInstruction>();\n\n  // TODO: cache component instruction instances by params and by ParsedUrl instance\n\n  constructor(private _routePath: RoutePath, public handler: RouteHandler,\n              private _routeName: string) {\n    this.specificity = this._routePath.specificity;\n    this.hash = this._routePath.hash;\n    this.terminal = this._routePath.terminal;\n  }\n\n  get path() { return this._routePath.toString(); }\n  set path(val) { throw new BaseException('you cannot set the path of a RouteRule directly'); }\n\n  recognize(beginningSegment: Url): Promise<RouteMatch> {\n    var res = this._routePath.matchUrl(beginningSegment);\n    if (isBlank(res)) {\n      return null;\n    }\n\n    return this.handler.resolveComponentType().then((_) => {\n      var componentInstruction = this._getInstruction(res.urlPath, res.urlParams, res.allParams);\n      return new PathMatch(componentInstruction, res.rest, res.auxiliary);\n    });\n  }\n\n  generate(params: {[key: string]: any}): ComponentInstruction {\n    var generated = this._routePath.generateUrl(params);\n    var urlPath = generated.urlPath;\n    var urlParams = generated.urlParams;\n    return this._getInstruction(urlPath, convertUrlParamsToArray(urlParams), params);\n  }\n\n  generateComponentPathValues(params: {[key: string]: any}): GeneratedUrl {\n    return this._routePath.generateUrl(params);\n  }\n\n  private _getInstruction(urlPath: string, urlParams: string[],\n                          params: {[key: string]: any}): ComponentInstruction {\n    if (isBlank(this.handler.componentType)) {\n      throw new BaseException(`Tried to get instruction before the type was loaded.`);\n    }\n    var hashKey = urlPath + '?' + urlParams.join('&');\n    if (this._cache.has(hashKey)) {\n      return this._cache.get(hashKey);\n    }\n    var instruction =\n        new ComponentInstruction(urlPath, urlParams, this.handler.data, this.handler.componentType,\n                                 this.terminal, this.specificity, params, this._routeName);\n    this._cache.set(hashKey, instruction);\n\n    return instruction;\n  }\n}\n"]}