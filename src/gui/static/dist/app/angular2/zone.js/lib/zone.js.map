{"version":3,"sources":["app/angular2/zone.js/lib/zone.ts"],"names":[],"mappings":"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","file":"zone.js","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Zone is a mechanism for intercepting and keeping track of asynchronous work.\n *\n * A Zone is a global object which is configured with rules about how to intercept and keep track\n * of the asynchronous callbacks. Zone has these responsibilities:\n *\n * 1. Intercept asynchronous task scheduling\n * 2. Wrap callbacks for error-handling and zone tracking across async operations.\n * 3. Provide a way to attach data to zones\n * 4. Provide a context specific last frame error handling\n * 5. (Intercept blocking methods)\n *\n * A zone by itself does not do anything, instead it relies on some other code to route existing\n * platform API through it. (The zone library ships with code which monkey patches all of the\n * browsers's asynchronous API and redirects them through the zone for interception.)\n *\n * In its simplest form a zone allows one to intercept the scheduling and calling of asynchronous\n * operations, and execute additional code before as well as after the asynchronous task. The rules\n * of interception are configured using [ZoneConfig]. There can be many different zone instances in\n * a system, but only one zone is active at any given time which can be retrieved using\n * [Zone#current].\n *\n *\n *\n * ## Callback Wrapping\n *\n * An important aspect of the zones is that they should persist across asynchronous operations. To\n * achieve this, when a future work is scheduled through async API, it is necessary to capture, and\n * subsequently restore the current zone. For example if a code is running in zone `b` and it\n * invokes `setTimeout` to scheduleTask work later, the `setTimeout` method needs to 1) capture the\n * current zone and 2) wrap the `wrapCallback` in code which will restore the current zone `b` once\n * the wrapCallback executes. In this way the rules which govern the current code are preserved in\n * all future asynchronous tasks. There could be a different zone `c` which has different rules and\n * is associated with different asynchronous tasks. As these tasks are processed, each asynchronous\n * wrapCallback correctly restores the correct zone, as well as preserves the zone for future\n * asynchronous callbacks.\n *\n * Example: Suppose a browser page consist of application code as well as third-party\n * advertisement code. (These two code bases are independent, developed by different mutually\n * unaware developers.) The application code may be interested in doing global error handling and\n * so it configures the `app` zone to send all of the errors to the server for analysis, and then\n * executes the application in the `app` zone. The advertising code is interested in the same\n * error processing but it needs to send the errors to a different third-party. So it creates the\n * `ads` zone with a different error handler. Now both advertising as well as application code\n * create many asynchronous operations, but the [Zone] will ensure that all of the asynchronous\n * operations created from the application code will execute in `app` zone with its error\n * handler and all of the advertisement code will execute in the `ads` zone with its error handler.\n * This will not only work for the async operations created directly, but also for all subsequent\n * asynchronous operations.\n *\n * If you think of chain of asynchronous operations as a thread of execution (bit of a stretch)\n * then [Zone#current] will act as a thread local variable.\n *\n *\n *\n * ## Asynchronous operation scheduling\n *\n * In addition to wrapping the callbacks to restore the zone, all operations which cause a\n * scheduling of work for later are routed through the current zone which is allowed to intercept\n * them by adding work before or after the wrapCallback as well as using different means of\n * achieving the request. (Useful for unit testing, or tracking of requests). In some instances\n * such as `setTimeout` the wrapping of the wrapCallback and scheduling is done in the same\n * wrapCallback, but there are other examples such as `Promises` where the `then` wrapCallback is\n * wrapped, but the execution of `then` in triggered by `Promise` scheduling `resolve` work.\n *\n * Fundamentally there are three kinds of tasks which can be scheduled:\n *\n * 1. [MicroTask] used for doing work right after the current task. This is non-cancelable which is\n *    guaranteed to run exactly once and immediately.\n * 2. [MacroTask] used for doing work later. Such as `setTimeout`. This is typically cancelable\n *    which is guaranteed to execute at least once after some well understood delay.\n * 3. [EventTask] used for listening on some future event. This may execute zero or more times, with\n *    an unknown delay.\n *\n * Each asynchronous API is modeled and routed through one of these APIs.\n *\n *\n * ### [MicroTask]\n *\n * [MicroTask]s represent work which will be done in current VM turn as soon as possible, before VM\n * yielding.\n *\n *\n * ### [TimerTask]\n *\n * [TimerTask]s represents work which will be done after some delay. (Sometimes the delay is\n * approximate such as on next available animation frame). Typically these methods include:\n * `setTimeout`, `setImmediate`, `setInterval`, `requestAnimationFrame`, and all browser specif\n * variants.\n *\n *\n * ### [EventTask]\n *\n * [EventTask]s represents a request to create a listener on an event. Unlike the other task\n * events may never be executed, but typically execute more then once. There is no queue of\n * events, rather their callbacks are unpredictable both in order and time.\n *\n *\n * ## Global Error Handling\n *\n *\n * ## Composability\n *\n * Zones can be composed together through [Zone.fork()]. A child zone may create its own set of\n * rules. A child zone is expected to either:\n *\n * 1. Delegate the interception to a parent zone, and optionally add before and after wrapCallback\n *    hook.s\n * 2) Or process the request itself without delegation.\n *\n * Composability allows zones to keep their concerns clean. For example a top most zone may chose\n * to handle error handling, while child zones may chose to do user action tracking.\n *\n *\n * ## Root Zone\n *\n * At the start the browser will run in a special root zone, which is configure to behave exactly\n * like the platform, making any existing code which is not-zone aware behave as expected. All\n * zones are children of the root zone.\n *\n */\ninterface Zone {\n  /**\n   *\n   * @returns {Zone} The parent Zone.\n   */\n  parent: Zone;\n  /**\n   * @returns {string} The Zone name (useful for debugging)\n   */\n  name: string;\n\n  /**\n   * Returns a value associated with the `key`.\n   *\n   * If the current zone does not have a key, the request is delegated to the parent zone. Use\n   * [ZoneSpec.properties] to configure the set of properties associated with the current zone.\n   *\n   * @param key The key to retrieve.\n   * @returns {any} The value for the key, or `undefined` if not found.\n   */\n  get(key: string): any;\n  /**\n   * Returns a Zone which defines a `key`.\n   *\n   * Recursively search the parent Zone until a Zone which has a property `key` is found.\n   *\n   * @param key The key to use for identification of the returned zone.\n   * @returns {Zone} The Zone which defines the `key`, `null` if not found.\n   */\n  getZoneWith(key: string): Zone;\n  /**\n   * Used to create a child zone.\n   *\n   * @param zoneSpec A set of rules which the child zone should follow.\n   * @returns {Zone} A new child zone.\n   */\n  fork(zoneSpec: ZoneSpec): Zone;\n  /**\n   * Wraps a callback function in a new function which will properly restore the current zone upon\n   * invocation.\n   *\n   * The wrapped function will properly forward `this` as well as `arguments` to the `callback`.\n   *\n   * Before the function is wrapped the zone can intercept the `callback` by declaring\n   * [ZoneSpec.onIntercept].\n   *\n   * @param callback the function which will be wrapped in the zone.\n   * @param source A unique debug location of the API being wrapped.\n   * @returns {function(): *} A function which will invoke the `callback` through [Zone.runGuarded].\n   */\n  wrap(callback: Function, source: string): Function;\n  /**\n   * Invokes a function in a given zone.\n   *\n   * The invocation of `callback` can be intercepted be declaring [ZoneSpec.onInvoke].\n   *\n   * @param callback The function to invoke.\n   * @param applyThis\n   * @param applyArgs\n   * @param source A unique debug location of the API being invoked.\n   * @returns {any} Value from the `callback` function.\n   */\n  run<T>(callback: Function, applyThis?: any, applyArgs?: any[], source?: string): T;\n  /**\n   * Invokes a function in a given zone and catches any exceptions.\n   *\n   * Any exceptions thrown will be forwarded to [Zone.HandleError].\n   *\n   * The invocation of `callback` can be intercepted be declaring [ZoneSpec.onInvoke]. The\n   * handling of exceptions can intercepted by declaring [ZoneSpec.handleError].\n   *\n   * @param callback The function to invoke.\n   * @param applyThis\n   * @param applyArgs\n   * @param source A unique debug location of the API being invoked.\n   * @returns {any} Value from the `callback` function.\n   */\n  runGuarded<T>(callback: Function, applyThis?: any, applyArgs?: any[], source?: string): T;\n  /**\n   * Execute the Task by restoring the [Zone.currentTask] in the Task's zone.\n   *\n   * @param callback\n   * @param applyThis\n   * @param applyArgs\n   * @returns {*}\n   */\n  runTask(task: Task, applyThis?: any, applyArgs?: any): any;\n  scheduleMicroTask(\n      source: string, callback: Function, data?: TaskData,\n      customSchedule?: (task: Task) => void): MicroTask;\n  scheduleMacroTask(\n      source: string, callback: Function, data: TaskData, customSchedule: (task: Task) => void,\n      customCancel: (task: Task) => void): MacroTask;\n  scheduleEventTask(\n      source: string, callback: Function, data: TaskData, customSchedule: (task: Task) => void,\n      customCancel: (task: Task) => void): EventTask;\n  /**\n   * Allows the zone to intercept canceling of scheduled Task.\n   *\n   * The interception is configured using [ZoneSpec.onCancelTask]. The default canceler invokes\n   * the [Task.cancelFn].\n   *\n   * @param task\n   * @returns {any}\n   */\n  cancelTask(task: Task): any;\n}\n\ninterface ZoneType {\n  /**\n   * @returns {Zone} Returns the current [Zone]. Returns the current zone. The only way to change\n   * the current zone is by invoking a run() method, which will update the current zone for the\n   * duration of the run method callback.\n   */\n  current: Zone;\n  /**\n   * @returns {Task} The task associated with the current execution.\n   */\n  currentTask: Task;\n\n  /**\n   * Verify that Zone has been correctly patched. Specifically that Promise is zone aware.\n   */\n  assertZonePatched();\n}\n\n/**\n * Provides a way to configure the interception of zone events.\n *\n * Only the `name` property is required (all other are optional).\n */\ninterface ZoneSpec {\n  /**\n   * The name of the zone. Usefull when debugging Zones.\n   */\n  name: string;\n\n  /**\n   * A set of properties to be associated with Zone. Use [Zone.get] to retrive them.\n   */\n  properties?: {[key: string]: any};\n\n  /**\n   * Allows the interception of zone forking.\n   *\n   * When the zone is being forked, the request is forwarded to this method for interception.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param zoneSpec The argument passed into the `fork` method.\n   */\n  onFork?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone,\n       zoneSpec: ZoneSpec) => Zone;\n\n  /**\n   * Allows interception of the wrapping of the callback.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param delegate The argument passed into the `warp` method.\n   * @param source The argument passed into the `warp` method.\n   */\n  onIntercept?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, delegate: Function,\n       source: string) => Function;\n\n  /**\n   * Allows interception of the callback invocation.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param delegate The argument passed into the `run` method.\n   * @param applyThis The argument passed into the `run` method.\n   * @param applyArgs The argument passed into the `run` method.\n   * @param source The argument passed into the `run` method.\n   */\n  onInvoke?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, delegate: Function,\n       applyThis: any, applyArgs: any[], source: string) => any;\n\n  /**\n   * Allows interception of the error handling.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param error The argument passed into the `handleError` method.\n   */\n  onHandleError?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone,\n       error: any) => boolean;\n\n  /**\n   * Allows interception of task scheduling.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param task The argument passed into the `scheduleTask` method.\n   */\n  onScheduleTask?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task) => Task;\n\n  onInvokeTask?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task,\n       applyThis: any, applyArgs: any) => any;\n\n  /**\n   * Allows interception of task cancelation.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param task The argument passed into the `cancelTask` method.\n   */\n  onCancelTask?:\n      (parentZoneDelegate: ZoneDelegate, currentZone: Zone, targetZone: Zone, task: Task) => any;\n\n  /**\n   * Notifies of changes to the task queue empty status.\n   *\n   * @param parentZoneDelegate Delegate which performs the parent [ZoneSpec] operation.\n   * @param currentZone The current [Zone] where the current interceptor has beed declared.\n   * @param targetZone The [Zone] which originally received the request.\n   * @param isEmpty\n   */\n  onHasTask?:\n      (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => void;\n}\n;\n\n/**\n *  A delegate when intercepting zone operations.\n *\n *  A ZoneDelegate is needed because a child zone can't simply invoke a method on a parent zone. For\n *  example a child zone wrap can't just call parent zone wrap. Doing so would create a callback\n *  which is bound to the parent zone. What we are interested is intercepting the callback before it\n *  is bound to any zone. Furthermore, we also need to pass the targetZone (zone which received the\n *  original request) to the delegate.\n *\n *  The ZoneDelegate methods mirror those of Zone with an addition of extra targetZone argument in\n *  the method signature. (The original Zone which received the request.) Some methods are renamed\n *  to prevent confusion, because they have slightly different semantics and arguments.\n *\n *  - `wrap` => `intercept`: The `wrap` method delegates to `intercept`. The `wrap` method returns\n *     a callback which will run in a given zone, where as intercept allows wrapping the callback\n *     so that additional code can be run before and after, but does not associated the callback\n *     with the zone.\n *  - `run` => `invoke`: The `run` method delegates to `invoke` to perform the actual execution of\n *     the callback. The `run` method switches to new zone; saves and restores the `Zone.current`;\n *     and optionally performs error handling. The invoke is not responsible for error handling,\n *     or zone management.\n *\n *  Not every method is usually overwritten in the child zone, for this reason the ZoneDelegate\n *  stores the closest zone which overwrites this behavior along with the closest ZoneSpec.\n *\n *  NOTE: We have tried to make this API analogous to Event bubbling with target and current\n *  properties.\n *\n *  Note: The ZoneDelegate treats ZoneSpec as class. This allows the ZoneSpec to use its `this` to\n *  store internal state.\n */\ninterface ZoneDelegate {\n  zone: Zone;\n  fork(targetZone: Zone, zoneSpec: ZoneSpec): Zone;\n  intercept(targetZone: Zone, callback: Function, source: string): Function;\n  invoke(targetZone: Zone, callback: Function, applyThis: any, applyArgs: any[], source: string):\n      any;\n  handleError(targetZone: Zone, error: any): boolean;\n  scheduleTask(targetZone: Zone, task: Task): Task;\n  invokeTask(targetZone: Zone, task: Task, applyThis: any, applyArgs: any): any;\n  cancelTask(targetZone: Zone, task: Task): any;\n  hasTask(targetZone: Zone, isEmpty: HasTaskState): void;\n}\n\ntype HasTaskState = {\n  microTask: boolean; macroTask: boolean; eventTask: boolean; change: TaskType;\n};\n\n/**\n * Task type: `microTask`, `macroTask`, `eventTask`.\n */\ntype TaskType = string; /* TS v1.8 => \"microTask\" | \"macroTask\" | \"eventTask\" */\n;\n\n/**\n */\ninterface TaskData {\n  /**\n   * A periodic [MacroTask] is such which get automatically rescheduled after it is executed.\n   */\n  isPeriodic?: boolean;\n\n  /**\n   * Delay in milliseconds when the Task will run.\n   */\n  delay?: number;\n\n  /**\n   * identifier returned by the native setTimeout.\n   */\n  handleId?: number;\n}\n\n/**\n * Represents work which is executed with a clean stack.\n *\n * Tasks are used in Zones to mark work which is performed on clean stack frame. There are three\n * kinds of task. [MicroTask], [MacroTask], and [EventTask].\n *\n * A JS VM can be modeled as a [MicroTask] queue, [MacroTask] queue, and [EventTask] set.\n *\n * - [MicroTask] queue represents a set of tasks which are executing right after the current stack\n *   frame becomes clean and before a VM yield. All [MicroTask]s execute in order of insertion\n *   before VM yield and the next [MacroTask] is executed.\n * - [MacroTask] queue represents a set of tasks which are executed one at a time after each VM\n *   yield. The queue is order by time, and insertions can happen in any location.\n * - [EventTask] is a set of tasks which can at any time be inserted to the end of the [MacroTask]\n *   queue. This happens when the event fires.\n *\n */\ninterface Task {\n  /**\n   * Task type: `microTask`, `macroTask`, `eventTask`.\n   */\n  type: TaskType;\n\n  /**\n   * Debug string representing the API which requested the scheduling of the task.\n   */\n  source: string;\n\n  /**\n   * The Function to be used by the VM on entering the [Task]. This function will delegate to\n   * [Zone.runTask] and delegate to `callback`.\n   */\n  invoke: Function;\n\n  /**\n   * Function which needs to be executed by the Task after the [Zone.currentTask] has been set to\n   * the current task.\n   */\n  callback: Function;\n\n  /**\n   * Task specific options associated with the current task. This is passed to the `scheduleFn`.\n   */\n  data: TaskData;\n\n  /**\n   * Represents the default work which needs to be done to schedule the Task by the VM.\n   *\n   * A zone may chose to intercept this function and perform its own scheduling.\n   */\n  scheduleFn: (task: Task) => void;\n\n  /**\n   * Represents the default work which needs to be done to un-schedule the Task from the VM. Not all\n   * Tasks are cancelable, and therefore this method is optional.\n   *\n   * A zone may chose to intercept this function and perform its own scheduling.\n   */\n  cancelFn: (task: Task) => void;\n\n  /**\n   * @type {Zone} The zone which will be used to invoke the `callback`. The Zone is captured\n   * at the time of Task creation.\n   */\n  zone: Zone;\n\n  /**\n   * Number of times the task has been executed, or -1 if canceled.\n   */\n  runCount: number;\n}\n\ninterface MicroTask extends Task {\n  /* TS v1.8 => type: 'microTask'; */\n}\n\ninterface MacroTask extends Task {\n  /* TS v1.8 => type: 'macroTask'; */\n}\n\ninterface EventTask extends Task {\n  /* TS v1.8 => type: 'eventTask'; */\n}\n\n/** @internal */\ntype AmbientZone = Zone;\n/** @internal */\ntype AmbientZoneDelegate = ZoneDelegate;\n\nconst Zone: ZoneType = (function(global: any) {\n  if (global.Zone) {\n    throw new Error('Zone already loaded.');\n  }\n\n  class Zone implements AmbientZone {\n    static __symbol__: (name: string) => string = __symbol__;\n\n    static assertZonePatched() {\n      if (global.Promise !== ZoneAwarePromise) {\n        throw new Error(\n            'Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n            'has been overwritten.\\n' +\n            'Most likely cause is that a Promise polyfill has been loaded ' +\n            'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n            'If you must load one, do so before loading zone.js.)');\n      }\n    }\n\n\n    static get current(): AmbientZone {\n      return _currentZone;\n    };\n    static get currentTask(): Task {\n      return _currentTask;\n    };\n\n    public get parent(): AmbientZone {\n      return this._parent;\n    };\n    public get name(): string {\n      return this._name;\n    };\n\n\n    private _parent: Zone;\n    private _name: string;\n    private _properties: {[key: string]: any} = null;\n    private _zoneDelegate: ZoneDelegate;\n\n    constructor(parent: Zone, zoneSpec: ZoneSpec) {\n      this._parent = parent;\n      this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n      this._properties = zoneSpec && zoneSpec.properties || {};\n      this._zoneDelegate =\n          new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n    }\n\n    public get(key: string): any {\n      const zone: Zone = this.getZoneWith(key) as Zone;\n      if (zone) return zone._properties[key];\n    }\n\n    public getZoneWith(key: string): AmbientZone {\n      let current: Zone = this;\n      while (current) {\n        if (current._properties.hasOwnProperty(key)) {\n          return current;\n        }\n        current = current._parent;\n      }\n      return null;\n    }\n\n    public fork(zoneSpec: ZoneSpec): AmbientZone {\n      if (!zoneSpec) throw new Error('ZoneSpec required!');\n      return this._zoneDelegate.fork(this, zoneSpec);\n    }\n\n    public wrap(callback: Function, source: string): Function {\n      if (typeof callback !== 'function') {\n        throw new Error('Expecting function got: ' + callback);\n      }\n      const _callback = this._zoneDelegate.intercept(this, callback, source);\n      const zone: Zone = this;\n      return function() {\n        return zone.runGuarded(_callback, this, <any>arguments, source);\n      };\n    }\n\n    public run(\n        callback: Function, applyThis: any = null, applyArgs: any[] = null, source: string = null) {\n      const oldZone = _currentZone;\n      _currentZone = this;\n      try {\n        return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n      } finally {\n        _currentZone = oldZone;\n      }\n    }\n\n    public runGuarded(\n        callback: Function, applyThis: any = null, applyArgs: any[] = null, source: string = null) {\n      const oldZone = _currentZone;\n      _currentZone = this;\n      try {\n        try {\n          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        _currentZone = oldZone;\n      }\n    }\n\n\n    runTask(task: Task, applyThis?: any, applyArgs?: any) {\n      task.runCount++;\n      if (task.zone != this)\n        throw new Error(\n            'A task can only be run in the zone which created it! (Creation: ' + task.zone.name +\n            '; Execution: ' + this.name + ')');\n      const previousTask = _currentTask;\n      _currentTask = task;\n      const oldZone = _currentZone;\n      _currentZone = this;\n      try {\n        if (task.type == 'macroTask' && task.data && !task.data.isPeriodic) {\n          task.cancelFn = null;\n        }\n        try {\n          return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        _currentZone = oldZone;\n        _currentTask = previousTask;\n      }\n    }\n\n\n    scheduleMicroTask(\n        source: string, callback: Function, data?: TaskData,\n        customSchedule?: (task: Task) => void): MicroTask {\n      return <MicroTask>this._zoneDelegate.scheduleTask(\n          this, new ZoneTask('microTask', this, source, callback, data, customSchedule, null));\n    }\n\n    scheduleMacroTask(\n        source: string, callback: Function, data: TaskData, customSchedule: (task: Task) => void,\n        customCancel: (task: Task) => void): MacroTask {\n      return <MacroTask>this._zoneDelegate.scheduleTask(\n          this,\n          new ZoneTask('macroTask', this, source, callback, data, customSchedule, customCancel));\n    }\n\n    scheduleEventTask(\n        source: string, callback: Function, data: TaskData, customSchedule: (task: Task) => void,\n        customCancel: (task: Task) => void): EventTask {\n      return <EventTask>this._zoneDelegate.scheduleTask(\n          this,\n          new ZoneTask('eventTask', this, source, callback, data, customSchedule, customCancel));\n    }\n\n    cancelTask(task: Task): any {\n      const value = this._zoneDelegate.cancelTask(this, task);\n      task.runCount = -1;\n      task.cancelFn = null;\n      return value;\n    }\n  };\n\n  class ZoneDelegate implements AmbientZoneDelegate {\n    public zone: Zone;\n\n    private _taskCounts: {microTask: number,\n                          macroTask: number,\n                          eventTask: number} = {microTask: 0, macroTask: 0, eventTask: 0};\n\n    private _parentDelegate: ZoneDelegate;\n\n    private _forkDlgt: ZoneDelegate;\n    private _forkZS: ZoneSpec;\n\n    private _interceptDlgt: ZoneDelegate;\n    private _interceptZS: ZoneSpec;\n\n    private _invokeDlgt: ZoneDelegate;\n    private _invokeZS: ZoneSpec;\n\n    private _handleErrorDlgt: ZoneDelegate;\n    private _handleErrorZS: ZoneSpec;\n\n    private _scheduleTaskDlgt: ZoneDelegate;\n    private _scheduleTaskZS: ZoneSpec;\n\n    private _invokeTaskDlgt: ZoneDelegate;\n    private _invokeTaskZS: ZoneSpec;\n\n    private _cancelTaskDlgt: ZoneDelegate;\n    private _cancelTaskZS: ZoneSpec;\n\n    private _hasTaskDlgt: ZoneDelegate;\n    private _hasTaskZS: ZoneSpec;\n\n    constructor(zone: Zone, parentDelegate: ZoneDelegate, zoneSpec: ZoneSpec) {\n      this.zone = zone;\n      this._parentDelegate = parentDelegate;\n\n      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n\n      this._interceptZS =\n          zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n      this._interceptDlgt =\n          zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n\n      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n      this._invokeDlgt =\n          zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n\n      this._handleErrorZS =\n          zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n      this._handleErrorDlgt =\n          zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n\n      this._scheduleTaskZS =\n          zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n      this._scheduleTaskDlgt =\n          zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n\n      this._invokeTaskZS =\n          zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n      this._invokeTaskDlgt =\n          zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n\n      this._cancelTaskZS =\n          zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n      this._cancelTaskDlgt =\n          zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n\n      this._hasTaskZS = zoneSpec && (zoneSpec.onHasTask ? zoneSpec : parentDelegate._hasTaskZS);\n      this._hasTaskDlgt =\n          zoneSpec && (zoneSpec.onHasTask ? parentDelegate : parentDelegate._hasTaskDlgt);\n    }\n\n    fork(targetZone: Zone, zoneSpec: ZoneSpec): AmbientZone {\n      return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                            new Zone(targetZone, zoneSpec);\n    }\n\n    intercept(targetZone: Zone, callback: Function, source: string): Function {\n      return this._interceptZS ?\n          this._interceptZS.onIntercept(\n              this._interceptDlgt, this.zone, targetZone, callback, source) :\n          callback;\n    }\n\n    invoke(targetZone: Zone, callback: Function, applyThis: any, applyArgs: any[], source: string):\n        any {\n      return this._invokeZS ?\n          this._invokeZS.onInvoke(\n              this._invokeDlgt, this.zone, targetZone, callback, applyThis, applyArgs, source) :\n          callback.apply(applyThis, applyArgs);\n    }\n\n    handleError(targetZone: Zone, error: any): boolean {\n      return this._handleErrorZS ?\n          this._handleErrorZS.onHandleError(this._handleErrorDlgt, this.zone, targetZone, error) :\n          true;\n    }\n\n    scheduleTask(targetZone: Zone, task: Task): Task {\n      try {\n        if (this._scheduleTaskZS) {\n          return this._scheduleTaskZS.onScheduleTask(\n              this._scheduleTaskDlgt, this.zone, targetZone, task);\n        } else if (task.scheduleFn) {\n          task.scheduleFn(task);\n        } else if (task.type == 'microTask') {\n          scheduleMicroTask(<MicroTask>task);\n        } else {\n          throw new Error('Task is missing scheduleFn.');\n        }\n        return task;\n      } finally {\n        if (targetZone == this.zone) {\n          this._updateTaskCount(task.type, 1);\n        }\n      }\n    }\n\n    invokeTask(targetZone: Zone, task: Task, applyThis: any, applyArgs: any): any {\n      try {\n        return this._invokeTaskZS ?\n            this._invokeTaskZS.onInvokeTask(\n                this._invokeTaskDlgt, this.zone, targetZone, task, applyThis, applyArgs) :\n            task.callback.apply(applyThis, applyArgs);\n      } finally {\n        if (targetZone == this.zone && (task.type != 'eventTask') &&\n            !(task.data && task.data.isPeriodic)) {\n          this._updateTaskCount(task.type, -1);\n        }\n      }\n    }\n\n    cancelTask(targetZone: Zone, task: Task): any {\n      let value;\n      if (this._cancelTaskZS) {\n        value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this.zone, targetZone, task);\n      } else if (!task.cancelFn) {\n        throw new Error('Task does not support cancellation, or is already canceled.');\n      } else {\n        value = task.cancelFn(task);\n      }\n      if (targetZone == this.zone) {\n        // this should not be in the finally block, because exceptions assume not canceled.\n        this._updateTaskCount(task.type, -1);\n      }\n      return value;\n    }\n\n    hasTask(targetZone: Zone, isEmpty: HasTaskState) {\n      return this._hasTaskZS &&\n          this._hasTaskZS.onHasTask(this._hasTaskDlgt, this.zone, targetZone, isEmpty);\n    }\n\n    private _updateTaskCount(type: TaskType, count: number) {\n      const counts = this._taskCounts;\n      const prev = counts[type];\n      const next = counts[type] = prev + count;\n      if (next < 0) {\n        throw new Error('More tasks executed then were scheduled.');\n      }\n      if (prev == 0 || next == 0) {\n        const isEmpty: HasTaskState = {\n          microTask: counts.microTask > 0,\n          macroTask: counts.macroTask > 0,\n          eventTask: counts.eventTask > 0,\n          change: type\n        };\n        try {\n          this.hasTask(this.zone, isEmpty);\n        } finally {\n          if (this._parentDelegate) {\n            this._parentDelegate._updateTaskCount(type, count);\n          }\n        }\n      }\n    }\n  }\n\n\n  class ZoneTask implements Task {\n    public type: TaskType;\n    public source: string;\n    public invoke: Function;\n    public callback: Function;\n    public data: TaskData;\n    public scheduleFn: (task: Task) => void;\n    public cancelFn: (task: Task) => void;\n    public zone: Zone;\n    public runCount: number = 0;\n\n    constructor(\n        type: TaskType, zone: Zone, source: string, callback: Function, options: TaskData,\n        scheduleFn: (task: Task) => void, cancelFn: (task: Task) => void) {\n      this.type = type;\n      this.zone = zone;\n      this.source = source;\n      this.data = options;\n      this.scheduleFn = scheduleFn;\n      this.cancelFn = cancelFn;\n      this.callback = callback;\n      const self = this;\n      this.invoke = function() {\n        _numberOfNestedTaskFrames++;\n        try {\n          return zone.runTask(self, this, <any>arguments);\n        } finally {\n          if (_numberOfNestedTaskFrames == 1) {\n            drainMicroTaskQueue();\n          }\n          _numberOfNestedTaskFrames--;\n        }\n      };\n    }\n\n    public toString() {\n      if (this.data && typeof this.data.handleId !== 'undefined') {\n        return this.data.handleId;\n      } else {\n        return Object.prototype.toString.call(this);\n      }\n    }\n  }\n\n  interface UncaughtPromiseError extends Error {\n    zone: AmbientZone;\n    task: Task;\n    promise: ZoneAwarePromise<any>;\n    rejection: any;\n  }\n\n  function __symbol__(name: string) {\n    return '__zone_symbol__' + name;\n  };\n  const symbolSetTimeout = __symbol__('setTimeout');\n  const symbolPromise = __symbol__('Promise');\n  const symbolThen = __symbol__('then');\n\n  let _currentZone: Zone = new Zone(null, null);\n  let _currentTask: Task = null;\n  let _microTaskQueue: Task[] = [];\n  let _isDrainingMicrotaskQueue: boolean = false;\n  const _uncaughtPromiseErrors: UncaughtPromiseError[] = [];\n  let _numberOfNestedTaskFrames = 0;\n\n  function scheduleQueueDrain() {\n    // if we are not running in any task, and there has not been anything scheduled\n    // we must bootstrap the initial task creation by manually scheduling the drain\n    if (_numberOfNestedTaskFrames == 0 && _microTaskQueue.length == 0) {\n      // We are not running in Task, so we need to kickstart the microtask queue.\n      if (global[symbolPromise]) {\n        global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);\n      } else {\n        global[symbolSetTimeout](drainMicroTaskQueue, 0);\n      }\n    }\n  }\n\n  function scheduleMicroTask(task: MicroTask) {\n    scheduleQueueDrain();\n    _microTaskQueue.push(task);\n  }\n\n  function consoleError(e: any) {\n    const rejection = e && e.rejection;\n    if (rejection) {\n      console.error(\n          'Unhandled Promise rejection:',\n          rejection instanceof Error ? rejection.message : rejection, '; Zone:',\n          (<Zone>e.zone).name, '; Task:', e.task && (<Task>e.task).source, '; Value:', rejection,\n          rejection instanceof Error ? rejection.stack : undefined);\n    }\n    console.error(e);\n  }\n\n  function drainMicroTaskQueue() {\n    if (!_isDrainingMicrotaskQueue) {\n      _isDrainingMicrotaskQueue = true;\n      while (_microTaskQueue.length) {\n        const queue = _microTaskQueue;\n        _microTaskQueue = [];\n        for (let i = 0; i < queue.length; i++) {\n          const task = queue[i];\n          try {\n            task.zone.runTask(task, null, null);\n          } catch (e) {\n            consoleError(e);\n          }\n        }\n      }\n      while (_uncaughtPromiseErrors.length) {\n        while (_uncaughtPromiseErrors.length) {\n          const uncaughtPromiseError: UncaughtPromiseError = _uncaughtPromiseErrors.shift();\n          try {\n            uncaughtPromiseError.zone.runGuarded(() => {\n              throw uncaughtPromiseError;\n            });\n          } catch (e) {\n            consoleError(e);\n          }\n        }\n      }\n      _isDrainingMicrotaskQueue = false;\n    }\n  }\n\n\n  function isThenable(value: any): boolean {\n    return value && value.then;\n  }\n\n  function forwardResolution(value: any): any {\n    return value;\n  }\n\n  function forwardRejection(rejection: any): any {\n    return ZoneAwarePromise.reject(rejection);\n  }\n\n  const symbolState: string = __symbol__('state');\n  const symbolValue: string = __symbol__('value');\n  const source: string = 'Promise.then';\n  const UNRESOLVED = null;\n  const RESOLVED = true;\n  const REJECTED = false;\n  const REJECTED_NO_CATCH = 0;\n\n  function makeResolver(promise: ZoneAwarePromise<any>, state: boolean): (value: any) => void {\n    return (v) => {\n      resolvePromise(promise, state, v);\n      // Do not return value or you will break the Promise spec.\n    };\n  }\n\n  function resolvePromise(\n      promise: ZoneAwarePromise<any>, state: boolean, value: any): ZoneAwarePromise<any> {\n    if (promise[symbolState] === UNRESOLVED) {\n      if (value instanceof ZoneAwarePromise && value[symbolState] !== UNRESOLVED) {\n        clearRejectedNoCatch(<Promise<any>>value);\n        resolvePromise(promise, value[symbolState], value[symbolValue]);\n      } else if (isThenable(value)) {\n        value.then(makeResolver(promise, state), makeResolver(promise, false));\n      } else {\n        promise[symbolState] = state;\n        const queue = promise[symbolValue];\n        promise[symbolValue] = value;\n\n        for (let i = 0; i < queue.length;) {\n          scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n        }\n        if (queue.length == 0 && state == REJECTED) {\n          promise[symbolState] = REJECTED_NO_CATCH;\n          try {\n            throw new Error(\n                'Uncaught (in promise): ' + value +\n                (value && value.stack ? '\\n' + value.stack : ''));\n          } catch (e) {\n            const error: UncaughtPromiseError = e;\n            error.rejection = value;\n            error.promise = promise;\n            error.zone = Zone.current;\n            error.task = Zone.currentTask;\n            _uncaughtPromiseErrors.push(error);\n            scheduleQueueDrain();\n          }\n        }\n      }\n    }\n    // Resolving an already resolved promise is a noop.\n    return promise;\n  }\n\n  function clearRejectedNoCatch(promise: ZoneAwarePromise<any>): void {\n    if (promise[symbolState] === REJECTED_NO_CATCH) {\n      promise[symbolState] = REJECTED;\n      for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n        if (promise === _uncaughtPromiseErrors[i].promise) {\n          _uncaughtPromiseErrors.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n\n  function scheduleResolveOrReject<R, U>(\n      promise: ZoneAwarePromise<any>, zone: AmbientZone, chainPromise: ZoneAwarePromise<any>,\n      onFulfilled?: (value: R) => U, onRejected?: (error: any) => U): void {\n    clearRejectedNoCatch(promise);\n    const delegate =\n        promise[symbolState] ? onFulfilled || forwardResolution : onRejected || forwardRejection;\n    zone.scheduleMicroTask(source, () => {\n      try {\n        resolvePromise(chainPromise, true, zone.run(delegate, null, [promise[symbolValue]]));\n      } catch (error) {\n        resolvePromise(chainPromise, false, error);\n      }\n    });\n  }\n\n  class ZoneAwarePromise<R> implements Promise<R> {\n    static resolve<R>(value: R): Promise<R> {\n      return resolvePromise(<ZoneAwarePromise<R>>new this(null), RESOLVED, value);\n    }\n\n    static reject<U>(error: U): Promise<U> {\n      return resolvePromise(<ZoneAwarePromise<U>>new this(null), REJECTED, error);\n    }\n\n    static race<R>(values: PromiseLike<any>[]): Promise<R> {\n      let resolve: (v: any) => void;\n      let reject: (v: any) => void;\n      let promise: any = new this((res, rej) => {\n        [resolve, reject] = [res, rej];\n      });\n      function onResolve(value) {\n        promise && (promise = null || resolve(value));\n      }\n      function onReject(error) {\n        promise && (promise = null || reject(error));\n      }\n\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n        value.then(onResolve, onReject);\n      }\n      return promise;\n    }\n\n    static all<R>(values): Promise<R> {\n      let resolve: (v: any) => void;\n      let reject: (v: any) => void;\n      let promise = new this((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      let count = 0;\n      const resolvedValues = [];\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n        value.then(\n            ((index) => (value) => {\n              resolvedValues[index] = value;\n              count--;\n              if (!count) {\n                resolve(resolvedValues);\n              }\n            })(count),\n            reject);\n        count++;\n      }\n      if (!count) resolve(resolvedValues);\n      return promise;\n    }\n\n    constructor(\n        executor:\n            (resolve: (value?: R|PromiseLike<R>) => void, reject: (error?: any) => void) => void) {\n      const promise: ZoneAwarePromise<R> = this;\n      if (!(promise instanceof ZoneAwarePromise)) {\n        throw new Error('Must be an instanceof Promise.');\n      }\n      promise[symbolState] = UNRESOLVED;\n      promise[symbolValue] = [];  // queue;\n      try {\n        executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n      } catch (e) {\n        resolvePromise(promise, false, e);\n      }\n    }\n\n    then<R, U>(\n        onFulfilled?: (value: R) => U | PromiseLike<U>,\n        onRejected?: (error: any) => U | PromiseLike<U>): Promise<R> {\n      const chainPromise: Promise<R> = new (this.constructor as typeof ZoneAwarePromise)(null);\n      const zone = Zone.current;\n      if (this[symbolState] == UNRESOLVED) {\n        (<any[]>this[symbolValue]).push(zone, chainPromise, onFulfilled, onRejected);\n      } else {\n        scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n      }\n      return chainPromise;\n    }\n\n    catch<U>(onRejected?: (error: any) => U | PromiseLike<U>): Promise<R> {\n      return this.then(null, onRejected);\n    }\n  }\n  // Protect against aggressive optimizers dropping seemingly unused properties.\n  // E.g. Closure Compiler in advanced mode.\n  ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n  ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n  ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n  ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n\n  const NativePromise = global[__symbol__('Promise')] = global.Promise;\n  global.Promise = ZoneAwarePromise;\n  function patchThen(NativePromise) {\n    const NativePromiseProtototype = NativePromise.prototype;\n    const NativePromiseThen = NativePromiseProtototype[__symbol__('then')] =\n        NativePromiseProtototype.then;\n    NativePromiseProtototype.then = function(onResolve, onReject) {\n      const nativePromise = this;\n      return new ZoneAwarePromise((resolve, reject) => {\n               NativePromiseThen.call(nativePromise, resolve, reject);\n             })\n          .then(onResolve, onReject);\n    };\n  }\n\n  if (NativePromise) {\n    patchThen(NativePromise);\n    if (typeof global['fetch'] !== 'undefined') {\n      let fetchPromise: Promise<any>;\n      try {\n        // In MS Edge this throws\n        fetchPromise = global['fetch']();\n      } catch (e) {\n        // In Chrome this throws instead.\n        fetchPromise = global['fetch']('about:blank');\n      }\n      // ignore output to prevent error;\n      fetchPromise.then(() => null, () => null);\n      if (fetchPromise.constructor != NativePromise &&\n          fetchPromise.constructor != ZoneAwarePromise) {\n        patchThen(fetchPromise.constructor);\n      }\n    }\n  }\n\n  // This is not part of public API, but it is usefull for tests, so we expose it.\n  Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n  return global.Zone = Zone;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\n"]}