{"version":3,"file":"view_resolver_mock.js","sourceRoot":"","sources":["../../../../modules/@angular/compiler/testing/view_resolver_mock.ts"],"names":[],"mappings":"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","sourcesContent":["interface DecoratorInvocation {\n    type: Function;\n    args?: any[];\n  }\n  import {Injectable, ViewMetadata, Type, BaseException} from '@angular/core';\nimport {ViewResolver} from '../index';\nimport {Map} from '../src/facade/collection';\nimport {isPresent, stringify, isBlank, isArray} from '../src/facade/lang';\nimport {resolveForwardRef} from '@angular/core';\nexport class MockViewResolver extends ViewResolver {\n  /** @internal */\n  _views = new Map<Type, ViewMetadata>();\n  /** @internal */\n  _inlineTemplates = new Map<Type, string>();\n  /** @internal */\n  _viewCache = new Map<Type, ViewMetadata>();\n  /** @internal */\n  _directiveOverrides = new Map<Type, Map<Type, Type>>();\n\n  constructor() { super(); }\n\n  /**\n   * Overrides the {@link ViewMetadata} for a component.\n   *\n   * @param {Type} component\n   * @param {ViewDefinition} view\n   */\n  setView(component: Type, view: ViewMetadata): void {\n    this._checkOverrideable(component);\n    this._views.set(component, view);\n  }\n\n  /**\n   * Overrides the inline template for a component - other configuration remains unchanged.\n   *\n   * @param {Type} component\n   * @param {string} template\n   */\n  setInlineTemplate(component: Type, template: string): void {\n    this._checkOverrideable(component);\n    this._inlineTemplates.set(component, template);\n  }\n\n  /**\n   * Overrides a directive from the component {@link ViewMetadata}.\n   *\n   * @param {Type} component\n   * @param {Type} from\n   * @param {Type} to\n   */\n  overrideViewDirective(component: Type, from: Type, to: Type): void {\n    this._checkOverrideable(component);\n\n    var overrides = this._directiveOverrides.get(component);\n\n    if (isBlank(overrides)) {\n      overrides = new Map<Type, Type>();\n      this._directiveOverrides.set(component, overrides);\n    }\n\n    overrides.set(from, to);\n  }\n\n  /**\n   * Returns the {@link ViewMetadata} for a component:\n   * - Set the {@link ViewMetadata} to the overridden view when it exists or fallback to the default\n   * `ViewResolver`,\n   *   see `setView`.\n   * - Override the directives, see `overrideViewDirective`.\n   * - Override the @View definition, see `setInlineTemplate`.\n   *\n   * @param component\n   * @returns {ViewDefinition}\n   */\n  resolve(component: Type): ViewMetadata {\n    var view = this._viewCache.get(component);\n    if (isPresent(view)) return view;\n\n    view = this._views.get(component);\n    if (isBlank(view)) {\n      view = super.resolve(component);\n    }\n\n    var directives = [];\n    var overrides = this._directiveOverrides.get(component);\n\n    if (isPresent(overrides) && isPresent(view.directives)) {\n      flattenArray(view.directives, directives);\n      overrides.forEach((to, from) => {\n        var srcIndex = directives.indexOf(from);\n        if (srcIndex == -1) {\n          throw new BaseException(\n              `Overriden directive ${stringify(from)} not found in the template of ${stringify(component)}`);\n        }\n        directives[srcIndex] = to;\n      });\n      view = new ViewMetadata(\n          {template: view.template, templateUrl: view.templateUrl, directives: directives});\n    }\n\n    var inlineTemplate = this._inlineTemplates.get(component);\n    if (isPresent(inlineTemplate)) {\n      view = new ViewMetadata(\n          {template: inlineTemplate, templateUrl: null, directives: view.directives});\n    }\n\n    this._viewCache.set(component, view);\n    return view;\n  }\n\n  /**\n   * @internal\n   *\n   * Once a component has been compiled, the AppProtoView is stored in the compiler cache.\n   *\n   * Then it should not be possible to override the component configuration after the component\n   * has been compiled.\n   *\n   * @param {Type} component\n   */\n  _checkOverrideable(component: Type): void {\n    var cached = this._viewCache.get(component);\n\n    if (isPresent(cached)) {\n      throw new BaseException(\n          `The component ${stringify(component)} has already been compiled, its configuration can not be changed`);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\nstatic ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n];\n}\n\nfunction flattenArray(tree: any[], out: Array<Type | any[]>): void {\n  for (var i = 0; i < tree.length; i++) {\n    var item = resolveForwardRef(tree[i]);\n    if (isArray(item)) {\n      flattenArray(item, out);\n    } else {\n      out.push(item);\n    }\n  }\n}\n"]}