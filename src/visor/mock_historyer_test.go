// Code generated by mockery v1.0.0. DO NOT EDIT.

package visor

import (
	cipher "github.com/SkycoinProject/skycoin/src/cipher"
	coin "github.com/SkycoinProject/skycoin/src/coin"

	dbutil "github.com/SkycoinProject/skycoin/src/visor/dbutil"

	historydb "github.com/SkycoinProject/skycoin/src/visor/historydb"

	mock "github.com/stretchr/testify/mock"
)

// MockHistoryer is an autogenerated mock type for the Historyer type
type MockHistoryer struct {
	mock.Mock
}

// AddressSeen provides a mock function with given fields: tx, address
func (_m *MockHistoryer) AddressSeen(tx *dbutil.Tx, address cipher.Address) (bool, error) {
	ret := _m.Called(tx, address)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, cipher.Address) bool); ok {
		r0 = rf(tx, address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*dbutil.Tx, cipher.Address) error); ok {
		r1 = rf(tx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Erase provides a mock function with given fields: tx
func (_m *MockHistoryer) Erase(tx *dbutil.Tx) error {
	ret := _m.Called(tx)

	var r0 error
	if rf, ok := ret.Get(0).(func(*dbutil.Tx) error); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ForEachTxn provides a mock function with given fields: tx, f
func (_m *MockHistoryer) ForEachTxn(tx *dbutil.Tx, f func(cipher.SHA256, *historydb.Transaction) error) error {
	ret := _m.Called(tx, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, func(cipher.SHA256, *historydb.Transaction) error) error); ok {
		r0 = rf(tx, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetOutputsForAddress provides a mock function with given fields: tx, address
func (_m *MockHistoryer) GetOutputsForAddress(tx *dbutil.Tx, address cipher.Address) ([]historydb.UxOut, error) {
	ret := _m.Called(tx, address)

	var r0 []historydb.UxOut
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, cipher.Address) []historydb.UxOut); ok {
		r0 = rf(tx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]historydb.UxOut)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*dbutil.Tx, cipher.Address) error); ok {
		r1 = rf(tx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransaction provides a mock function with given fields: tx, hash
func (_m *MockHistoryer) GetTransaction(tx *dbutil.Tx, hash cipher.SHA256) (*historydb.Transaction, error) {
	ret := _m.Called(tx, hash)

	var r0 *historydb.Transaction
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, cipher.SHA256) *historydb.Transaction); ok {
		r0 = rf(tx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*historydb.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*dbutil.Tx, cipher.SHA256) error); ok {
		r1 = rf(tx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionsForAddress provides a mock function with given fields: tx, address, page
func (_m *MockHistoryer) GetTransactionsForAddress(tx *dbutil.Tx, address cipher.Address, page *historydb.PageIndex) ([]historydb.Transaction, uint64, error) {
	ret := _m.Called(tx, address, page)

	var r0 []historydb.Transaction
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, cipher.Address, *historydb.PageIndex) []historydb.Transaction); ok {
		r0 = rf(tx, address, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]historydb.Transaction)
		}
	}

	var r1 uint64
	if rf, ok := ret.Get(1).(func(*dbutil.Tx, cipher.Address, *historydb.PageIndex) uint64); ok {
		r1 = rf(tx, address, page)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*dbutil.Tx, cipher.Address, *historydb.PageIndex) error); ok {
		r2 = rf(tx, address, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetUxOuts provides a mock function with given fields: tx, uxids
func (_m *MockHistoryer) GetUxOuts(tx *dbutil.Tx, uxids []cipher.SHA256) ([]historydb.UxOut, error) {
	ret := _m.Called(tx, uxids)

	var r0 []historydb.UxOut
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, []cipher.SHA256) []historydb.UxOut); ok {
		r0 = rf(tx, uxids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]historydb.UxOut)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*dbutil.Tx, []cipher.SHA256) error); ok {
		r1 = rf(tx, uxids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NeedsReset provides a mock function with given fields: tx
func (_m *MockHistoryer) NeedsReset(tx *dbutil.Tx) (bool, error) {
	ret := _m.Called(tx)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*dbutil.Tx) bool); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*dbutil.Tx) error); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseBlock provides a mock function with given fields: tx, b
func (_m *MockHistoryer) ParseBlock(tx *dbutil.Tx, b coin.Block) error {
	ret := _m.Called(tx, b)

	var r0 error
	if rf, ok := ret.Get(0).(func(*dbutil.Tx, coin.Block) error); ok {
		r0 = rf(tx, b)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ParsedBlockSeq provides a mock function with given fields: tx
func (_m *MockHistoryer) ParsedBlockSeq(tx *dbutil.Tx) (uint64, bool, error) {
	ret := _m.Called(tx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*dbutil.Tx) uint64); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*dbutil.Tx) bool); ok {
		r1 = rf(tx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*dbutil.Tx) error); ok {
		r2 = rf(tx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}
