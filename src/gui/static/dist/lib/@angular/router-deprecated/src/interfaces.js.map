{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["../../../../modules/@angular/router-deprecated/src/interfaces.ts"],"names":[],"mappings":";AACA,qBAAqB,oBAAoB,CAAC,CAAA;AAE1C,0EAA0E;AAC1E,yEAAyE;AACzE,+DAA+D;AAC/D,IAAI,WAAW,GAAG,aAAM,CAAC;AACzB,IAAI,0BAA0B,GAAiB,IAAI,CAAC","sourcesContent":["import {ComponentInstruction} from './instruction';\nimport {global} from '../src/facade/lang';\n\n// This is here only so that after TS transpilation the file is not empty.\n// TODO(rado): find a better way to fix this, or remove if likely culprit\n// https://github.com/systemjs/systemjs/issues/487 gets closed.\nvar __ignore_me = global;\nvar __make_dart_analyzer_happy: Promise<any> = null;\n\n/**\n * Defines route lifecycle method `routerOnActivate`, which is called by the router at the end of a\n * successful route navigation.\n *\n * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\n * will be called depending on the result of {@link CanReuse}.\n *\n * The `routerOnActivate` hook is called with two {@link ComponentInstruction}s as parameters, the\n * first\n * representing the current route being navigated to, and the second parameter representing the\n * previous route or `null`.\n *\n * If `routerOnActivate` returns a promise, the route change will wait until the promise settles to\n * instantiate and activate child components.\n *\n * ### Example\n * {@example router/ts/on_activate/on_activate_example.ts region='routerOnActivate'}\n */\nexport interface OnActivate {\n  routerOnActivate(nextInstruction: ComponentInstruction,\n                   prevInstruction: ComponentInstruction): any |\n      Promise<any>;\n}\n\n/**\n * Defines route lifecycle method `routerOnReuse`, which is called by the router at the end of a\n * successful route navigation when {@link CanReuse} is implemented and returns or resolves to true.\n *\n * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\n * will be called, depending on the result of {@link CanReuse}.\n *\n * The `routerOnReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\n * first\n * representing the current route being navigated to, and the second parameter representing the\n * previous route or `null`.\n *\n * ### Example\n * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\n */\nexport interface OnReuse {\n  routerOnReuse(nextInstruction: ComponentInstruction, prevInstruction: ComponentInstruction): any |\n      Promise<any>;\n}\n\n/**\n * Defines route lifecycle method `routerOnDeactivate`, which is called by the router before\n * destroying\n * a component as part of a route change.\n *\n * The `routerOnDeactivate` hook is called with two {@link ComponentInstruction}s as parameters, the\n * first\n * representing the current route being navigated to, and the second parameter representing the\n * previous route.\n *\n * If `routerOnDeactivate` returns a promise, the route change will wait until the promise settles.\n *\n * ### Example\n * {@example router/ts/on_deactivate/on_deactivate_example.ts region='routerOnDeactivate'}\n */\nexport interface OnDeactivate {\n  routerOnDeactivate(nextInstruction: ComponentInstruction,\n                     prevInstruction: ComponentInstruction): any |\n      Promise<any>;\n}\n\n/**\n * Defines route lifecycle method `routerCanReuse`, which is called by the router to determine\n * whether a\n * component should be reused across routes, or whether to destroy and instantiate a new component.\n *\n * The `routerCanReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\n * first\n * representing the current route being navigated to, and the second parameter representing the\n * previous route.\n *\n * If `routerCanReuse` returns or resolves to `true`, the component instance will be reused and the\n * {@link OnDeactivate} hook will be run. If `routerCanReuse` returns or resolves to `false`, a new\n * component will be instantiated, and the existing component will be deactivated and removed as\n * part of the navigation.\n *\n * If `routerCanReuse` throws or rejects, the navigation will be cancelled.\n *\n * ### Example\n * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\n */\nexport interface CanReuse {\n  routerCanReuse(nextInstruction: ComponentInstruction,\n                 prevInstruction: ComponentInstruction): boolean |\n      Promise<boolean>;\n}\n\n/**\n * Defines route lifecycle method `routerCanDeactivate`, which is called by the router to determine\n * if a component can be removed as part of a navigation.\n *\n * The `routerCanDeactivate` hook is called with two {@link ComponentInstruction}s as parameters,\n * the\n * first representing the current route being navigated to, and the second parameter\n * representing the previous route.\n *\n * If `routerCanDeactivate` returns or resolves to `false`, the navigation is cancelled. If it\n * returns or\n * resolves to `true`, then the navigation continues, and the component will be deactivated\n * (the {@link OnDeactivate} hook will be run) and removed.\n *\n * If `routerCanDeactivate` throws or rejects, the navigation is also cancelled.\n *\n * ### Example\n * {@example router/ts/can_deactivate/can_deactivate_example.ts region='routerCanDeactivate'}\n */\nexport interface CanDeactivate {\n  routerCanDeactivate(nextInstruction: ComponentInstruction,\n                      prevInstruction: ComponentInstruction): boolean |\n      Promise<boolean>;\n}\n"]}