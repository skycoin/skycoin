{"version":3,"file":"mock_backend.js","sourceRoot":"","sources":["../../../../modules/@angular/http/testing/mock_backend.ts"],"names":[],"mappings":"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","sourcesContent":["interface DecoratorInvocation {\n    type: Function;\n    args?: any[];\n  }\n  import {Injectable} from '@angular/core';\nimport {Request} from '../src/static_request';\nimport {Response} from '../src/static_response';\nimport {ReadyState} from '../src/enums';\nimport {Connection, ConnectionBackend} from '../src/interfaces';\nimport {isPresent} from '../src/facade/lang';\nimport {BaseException} from '../src/facade/exceptions';\nimport {Subject} from 'rxjs/Subject';\nimport {ReplaySubject} from 'rxjs/ReplaySubject';\nimport {take} from 'rxjs/operator/take';\n\n/**\n *\n * Mock Connection to represent a {@link Connection} for tests.\n *\n **/\nexport class MockConnection implements Connection {\n  // TODO Name `readyState` should change to be more generic, and states could be made to be more\n  // descriptive than XHR states.\n  /**\n   * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n   * additional states. For example, state 5 indicates an aborted connection.\n   */\n  readyState: ReadyState;\n\n  /**\n   * {@link Request} instance used to create the connection.\n   */\n  request: Request;\n\n  /**\n   * {@link EventEmitter} of {@link Response}. Can be subscribed to in order to be notified when a\n   * response is available.\n   */\n  response: ReplaySubject<Response>;\n\n  constructor(req: Request) {\n    this.response = <any>take.call(new ReplaySubject(1), 1);\n    this.readyState = ReadyState.Open;\n    this.request = req;\n  }\n\n  /**\n   * Sends a mock response to the connection. This response is the value that is emitted to the\n   * {@link EventEmitter} returned by {@link Http}.\n   *\n   * ### Example\n   *\n   * ```\n   * var connection;\n   * backend.connections.subscribe(c => connection = c);\n   * http.request('data.json').subscribe(res => console.log(res.text()));\n   * connection.mockRespond(new Response('fake response')); //logs 'fake response'\n   * ```\n   *\n   */\n  mockRespond(res: Response) {\n    if (this.readyState === ReadyState.Done || this.readyState === ReadyState.Cancelled) {\n      throw new BaseException('Connection has already been resolved');\n    }\n    this.readyState = ReadyState.Done;\n    this.response.next(res);\n    this.response.complete();\n  }\n\n  /**\n   * Not yet implemented!\n   *\n   * Sends the provided {@link Response} to the `downloadObserver` of the `Request`\n   * associated with this connection.\n   */\n  mockDownload(res: Response) {\n    // this.request.downloadObserver.onNext(res);\n    // if (res.bytesLoaded === res.totalBytes) {\n    //   this.request.downloadObserver.onCompleted();\n    // }\n  }\n\n  // TODO(jeffbcross): consider using Response type\n  /**\n   * Emits the provided error object as an error to the {@link Response} {@link EventEmitter}\n   * returned\n   * from {@link Http}.\n   */\n  mockError(err?: Error) {\n    // Matches XHR semantics\n    this.readyState = ReadyState.Done;\n    this.response.error(err);\n  }\n}\nexport class MockBackend implements ConnectionBackend {\n  /**\n   * {@link EventEmitter}\n   * of {@link MockConnection} instances that have been created by this backend. Can be subscribed\n   * to in order to respond to connections.\n   *\n   * ### Example\n   *\n   * ```\n   * import {Http, BaseRequestOptions} from '@angular/http';\n   * import {MockBackend} from '@angular/http/testing';\n   * import {Injector} from '@angular/core';\n   *\n   * it('should get a response', () => {\n   *   var connection; //this will be set when a new connection is emitted from the backend.\n   *   var text; //this will be set from mock response\n   *   var injector = Injector.resolveAndCreate([\n   *     MockBackend,\n   *     provide(Http, {useFactory: (backend, options) => {\n   *       return new Http(backend, options);\n   *     }, deps: [MockBackend, BaseRequestOptions]}]);\n   *   var backend = injector.get(MockBackend);\n   *   var http = injector.get(Http);\n   *   backend.connections.subscribe(c => connection = c);\n   *   http.request('something.json').subscribe(res => {\n   *     text = res.text();\n   *   });\n   *   connection.mockRespond(new Response({body: 'Something'}));\n   *   expect(text).toBe('Something');\n   * });\n   * ```\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connections: any;  //<MockConnection>\n\n  /**\n   * An array representation of `connections`. This array will be updated with each connection that\n   * is created by this backend.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connectionsArray: MockConnection[];\n  /**\n   * {@link EventEmitter} of {@link MockConnection} instances that haven't yet been resolved (i.e.\n   * with a `readyState`\n   * less than 4). Used internally to verify that no connections are pending via the\n   * `verifyNoPendingRequests` method.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  pendingConnections: any;  // Subject<MockConnection>\n  constructor() {\n    this.connectionsArray = [];\n    this.connections = new Subject();\n    this.connections.subscribe((connection: MockConnection) =>\n                                   this.connectionsArray.push(connection));\n    this.pendingConnections = new Subject();\n  }\n\n  /**\n   * Checks all connections, and raises an exception if any connection has not received a response.\n   *\n   * This method only exists in the mock implementation, not in real Backends.\n   */\n  verifyNoPendingRequests() {\n    let pending = 0;\n    this.pendingConnections.subscribe((c: MockConnection) => pending++);\n    if (pending > 0) throw new BaseException(`${pending} pending connections to be resolved`);\n  }\n\n  /**\n   * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n   * connections, if it's expected that there are connections that have not yet received a response.\n   *\n   * This method only exists in the mock implementation, not in real Backends.\n   */\n  resolveAllConnections() { this.connections.subscribe((c: MockConnection) => c.readyState = 4); }\n\n  /**\n   * Creates a new {@link MockConnection}. This is equivalent to calling `new\n   * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n   * emitter of this `MockBackend` instance. This method will usually only be used by tests\n   * against the framework itself, not by end-users.\n   */\n  createConnection(req: Request): MockConnection {\n    if (!isPresent(req) || !(req instanceof Request)) {\n      throw new BaseException(`createConnection requires an instance of Request, got ${req}`);\n    }\n    let connection = new MockConnection(req);\n    this.connections.next(connection);\n    return connection;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\nstatic ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n];\n}\n"]}