We will have a configuration file that has a list of nodes(public keys)
and will define the transports for each node
the ports for incoming, IP and port to send to for outgoing
and there will be two halves of each transport and both halves have to be active for transport to work
each node will read the configuration file (probably json) and then setup the transport

type TransportData struct {
	PubKey cipher.PubKey `json:"pubkey"`
	Transports []struct {
		IncomingPort int `json:"incoming_port"`
		OutgoingIP string `json:"outgoing_ip"`
		OutgoingPort int `json:"outgoing_port"`
	} `json:"transports"`
}

{
 []:{
 "pubkey":[],
 "transports":[
   {
    "incoming_port": 15000,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 17000
   },
   {
    "incoming_port": 15001,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 17001
   }
  ]
 },
 []:{
 "pubkey":[],
 "transports":[
   {
    "incoming_port": 16000,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 18000
   }
  ]
 },
 {
 "pubkey":[3,0,0,0,0,0,0,0,0,0,0],
 "transports":[
   {
    "incoming_port": 17000,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 15000
   }
  ]
 },
 {
 "pubkey":[4,0,0,0,0,0,0,0,0,0,0],
 "transports":[
   {
    "incoming_port": 18000,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 16000
   }
  ]
 },
 {
 "pubkey":[5,0,0,0,0,0,0,0,0,0,0],
 "transports":[
   {
    "incoming_port": 17001,
    "outgoing_ip": "127.0.0.1",
    "outgoing_port": 15001
   }
  ]
 }
]
