{"version":3,"file":"upgrade_module.js","sourceRoot":"","sources":["../../../../../modules/@angular/upgrade/src/aot/upgrade_module.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModule, NgZone, Testability} from '@angular/core';\n\nimport * as angular from '../angular_js';\nimport {controllerKey} from '../util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {$$TESTABILITY, $DELEGATE, $INJECTOR, $PROVIDE, $ROOT_SCOPE, INJECTOR_KEY, UPGRADE_MODULE_NAME} from './constants';\n/**\n *  *\n  * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)\n  * library for hybrid upgrade apps that support AoT compilation*\n  * *\n  * Allows Angular 1 and Angular 2+ components to be used together inside a hybrid upgrade\n  * application, which supports AoT compilation.\n  * *\n  * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n  * 1. Creation of an Angular 2+ directive that wraps and exposes an Angular 1 component so\n  * that it can be used in an Angular 2 template. See {@link UpgradeComponent}.\n  * 2. Creation of an Angular 1 directive that wraps and exposes an Angular 2+ component so\n  * that it can be used in an Angular 1 template. See {@link downgradeComponent}.\n  * 3. Creation of an Angular 2+ root injector provider that wraps and exposes an Angular 1\n  * service so that it can be injected into an Angular 2+ context. See\n  * {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an Angular 1 service} below.\n  * 4. Creation of an Angular 1 service that wraps and exposes an Angular 2+ injectable\n  * so that it can be injected into an Angular 1 context. See {@link downgradeInjectable}.\n  * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n  * coexisting in a single application. See the\n  * {@link UpgradeModule#example example} below.\n  * *\n  * ## Mental Model\n  * *\n  * When reasoning about how a hybrid application works it is useful to have a mental model which\n  * describes what is happening and explains what is happening at the lowest level.\n  * *\n  * 1. There are two independent frameworks running in a single application, each framework treats\n  * the other as a black box.\n  * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n  * instantiated the element is the owner. Each framework only updates/interacts with its own\n  * DOM elements and ignores others.\n  * 3. Angular 1 directives always execute inside the Angular 1 framework codebase regardless of\n  * where they are instantiated.\n  * 4. Angular 2+ components always execute inside the Angular 2+ framework codebase regardless of\n  * where they are instantiated.\n  * 5. An Angular 1 component can be \"upgraded\"\" to an Angular 2+ component. This is achieved by\n  * defining an Angular 2+ directive, which bootstraps the Angular 1 component at its location\n  * in the DOM. See {@link UpgradeComponent}.\n  * 6. An Angular 2+ component can be \"downgraded\"\" to an Angular 1 component. This is achieved by\n  * defining an Angular 1 directive, which bootstraps the Angular 2+ component at its location\n  * in the DOM. See {@link downgradeComponent}.\n  * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n  * the framework doing the instantiation. The other framework then instantiates and owns the\n  * view for that component.\n  * a. This implies that the component bindings will always follow the semantics of the\n  * instantiation framework.\n  * b. The DOM attributes are parsed by the framework that owns the current template. So\n  * attributes\n  * in Angular 1 templates must use kebab-case, while Angular 1 templates must use camelCase.\n  * c. However the template binding syntax will always use the Angular 2+ style, e.g. square\n  * brackets (`[...]`) for property binding.\n  * 8. Angular 1 is always bootstrapped first and owns the root component.\n  * 9. The new application is running in an Angular 2+ zone, and therefore it no longer needs calls\n  * to\n  * `$apply()`.\n  * *\n  * *\n  * `import {UpgradeModule} from '@angular/upgrade/static';`\n  * *\n  * ## Example\n  * Import the {@link UpgradeModule} into your top level {@link NgModule Angular 2+ `NgModule`}.\n  * *\n  * {@example upgrade/static/ts/module.ts region='ng2-module'}\n  * *\n  * Then bootstrap the hybrid upgrade app's module, get hold of the {@link UpgradeModule} instance\n  * and use it to bootstrap the top level [Angular 1\n  * module](https://docs.angularjs.org/api/ng/type/angular.Module).\n  * *\n  * {@example upgrade/static/ts/module.ts region='bootstrap'}\n  * *\n  * *\n  * ## Upgrading an Angular 1 service\n  * *\n  * There is no specific API for upgrading an Angular 1 service. Instead you should just follow the\n  * following recipe:\n  * *\n  * Let's say you have an Angular 1 service:\n  * *\n  * {@example upgrade/static/ts/module.ts region=\"ng1-title-case-service\"}\n  * *\n  * Then you should define an Angular 2+ provider to be included in your {@link NgModule} `providers`\n  * property.\n  * *\n  * {@example upgrade/static/ts/module.ts region=\"upgrade-ng1-service\"}\n  * *\n  * Then you can use the \"upgraded\" Angular 1 service by injecting it into an Angular 2 component\n  * or service.\n  * *\n  * {@example upgrade/static/ts/module.ts region=\"use-ng1-upgraded-service\"}\n  * *\n  * *\n  * This class is an `NgModule`, which you import to provide Angular 1 core services,\n  * and has an instance method used to bootstrap the hybrid upgrade application.\n  * *\n  * ## Core Angular 1 services\n  * Importing this {@link NgModule} will add providers for the core\n  * [Angular 1 services](https://docs.angularjs.org/api/ng/service) to the root injector.\n  * *\n  * ## Bootstrap\n  * The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\n  * method, which you use to bootstrap the top level Angular 1 module onto an element in the\n  * DOM for the hybrid upgrade app.\n  * *\n  * It also contains properties to access the {@link UpgradeModule#injector root injector}, the\n  * bootstrap {@link NgZone} and the\n  * [Angular 1 $injector](https://docs.angularjs.org/api/auto/service/$injector).\n  * *\n */\nexport class UpgradeModule {\npublic $injector: any /*angular.IInjectorService*/;\n/**\n * @param {?} injector\n * @param {?} ngZone\n */\nconstructor(\npublic injector: Injector,\npublic ngZone: NgZone) {}\n/**\n *  Bootstrap an Angular 1 application from this NgModule\n * @param {?} element the element on which to bootstrap the Angular 1 application\n * @param {?=} modules\n * @param {?=} config\n * @return {?}\n */\nbootstrap(\n      element: Element, modules: string[] = [], config?: any /*angular.IAngularBootstrapConfig*/) {\n    // Create an ng1 module to bootstrap\n    const /** @type {?} */ upgradeModule =\n        angular\n            .module(UPGRADE_MODULE_NAME, modules)\n\n            .value(INJECTOR_KEY, this.injector)\n\n            .config([\n              $PROVIDE, $INJECTOR,\n              ($provide: angular.IProvideService, $injector: angular.IInjectorService) => {\n                if ($injector.has($$TESTABILITY)) {\n                  $provide.decorator($$TESTABILITY, [\n                    $DELEGATE,\n                    (testabilityDelegate: angular.ITestabilityService) => {\n                      const /** @type {?} */ originalWhenStable: Function = testabilityDelegate.whenStable;\n                      const /** @type {?} */ injector = this.injector;\n                      // Cannot use arrow function below because we need the context\n                      const /** @type {?} */ newWhenStable = function(callback: Function) {\n                        originalWhenStable.call(this, function() {\n                          const /** @type {?} */ ng2Testability: Testability = injector.get(Testability);\n                          if (ng2Testability.isStable()) {\n                            callback.apply(this, arguments);\n                          } else {\n                            ng2Testability.whenStable(newWhenStable.bind(this, callback));\n                          }\n                        });\n                      };\n\n                      testabilityDelegate.whenStable = newWhenStable;\n                      return testabilityDelegate;\n                    }\n                  ]);\n                }\n              }\n            ])\n\n            .run([\n              $INJECTOR,\n              ($injector: angular.IInjectorService) => {\n                this.$injector = $injector;\n\n                // Initialize the ng1 $injector provider\n                setTempInjectorRef($injector);\n                this.injector.get($INJECTOR);\n\n                // Put the injector on the DOM, so that it can be \"required\"\n                angular.element(element).data(controllerKey(INJECTOR_KEY), this.injector);\n\n                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n                const /** @type {?} */ $rootScope = $injector.get('$rootScope');\n                this.ngZone.onMicrotaskEmpty.subscribe(\n                    () => this.ngZone.runOutsideAngular(() => $rootScope.$evalAsync()));\n              }\n            ]);\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const /** @type {?} */ windowAngular = ( /** @type {?} */((window as any)) /** TODO #???? */)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the angular 1 application inside our zone\n    this.ngZone.run(() => { angular.bootstrap(element, [upgradeModule.name], config); });\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const /** @type {?} */ originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const /** @type {?} */ ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function() {\n        let /** @type {?} */ args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        ngZone.run(() => { windowAngular.resumeBootstrap.apply(this, args); });\n      };\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{providers: angular1Providers}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: NgZone, },\n];\n}\n\nfunction UpgradeModule_tsickle_Closure_declarations() {\n /** @type {?} */\nUpgradeModule.decorators;\n /**\n  * @nocollapse\n  * @type {?}\n  */\nUpgradeModule.ctorParameters;\n /**\n  * The Angular 1 `$injector` for the upgrade application.\n  * @type {?}\n  */\nUpgradeModule.prototype.$injector;\n /**\n  * The root {@link Injector} for the upgrade application.\n  * @type {?}\n  */\nUpgradeModule.prototype.injector;\n /**\n  * The bootstrap zone for the upgrade application\n  * @type {?}\n  */\nUpgradeModule.prototype.ngZone;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}