{"version":3,"file":"config.js","sourceRoot":"","sources":["../../../../modules/@angular/router/src/config.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {PRIMARY_OUTLET, Params} from './shared';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * @whatItDoes Represents router configuration.\n *\n * @description\n * `Routes` is an array of route configurations. Each one has the following properties:\n *\n * - `path` is a string that uses the route matcher DSL.\n * - `pathMatch` is a string that specifies the matching strategy.\n * - `component` is a component type.\n * - `redirectTo` is the url fragment which will replace the current matched segment.\n * - `outlet` is the name of the outlet the component should be placed into.\n * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See {@link\n * CanActivate} for more info.\n * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See\n * {@link\n * CanActivateChild} for more info.\n * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See {@link\n * CanDeactivate} for more info.\n * - `data` is additional data provided to the component via `ActivatedRoute`.\n * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more\n * info.\n * - `children` is an array of child route definitions.\n *\n * ### Simple Configuration\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/bob`, the router will create the team component with the user\n * component in it.\n *\n * ### Multiple Outlets\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * },\n * {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to\n * the chat component. The chat component will be placed into the aux outlet.\n *\n * ### Wild Cards\n *\n * ```\n * [{\n *   path: '**',\n *   component: Sink\n * }]\n * ```\n *\n * Regardless of where you navigate to, the router will instantiate the sink component.\n *\n * ### Redirects\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: 'legacy/user/:name',\n *       redirectTo: 'user/:name'\n *     },\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to '/team/11/legacy/user/jim', the router will change the url to\n * '/team/11/user/jim', and then will instantiate the team component with the user component\n * in it.\n *\n * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the\n * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.\n *\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any url segments. Let's look at the following configuration:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: '',\n *       component: AllUsers\n *     },\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11`, the router will instantiate the AllUsers component.\n *\n * Empty-path routes can have children.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: '',\n *       component: WrapperCmp,\n *       children: [\n *         {\n *           path: 'user/:name',\n *           component: User\n *         }\n *       ]\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with\n * the user component in it.\n *\n * An empty path route inherits its parent's params and data. This is because it cannot have its\n * own params, and, as a result, it often uses its parent's params and data as its own.\n *\n * ### Matching Strategy\n *\n * By default the router will look at what is left in the url, and check if it starts with\n * the specified path (e.g., `/team/11/user` starts with `team/:id`).\n *\n * We can change the matching strategy to make sure that the path covers the whole unconsumed url,\n * which is akin to `unconsumedUrl === path` or `$` regular expressions.\n *\n * This is particularly important when redirecting empty-path routes.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * },\n * {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * Since an empty path is a prefix of any url, even when navigating to '/main', the router will\n * still apply the redirect.\n *\n * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to\n * '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * },\n * {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * It is useful at times to have the ability to share parameters between sibling components.\n *\n * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\n * of them require some id parameter.\n *\n * One way to do that would be to have a bogus parent component, so both the siblings can get the id\n * parameter from it. This is not ideal. Instead, you can use a componentless route.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux\n * child components next to each other. In this example, the application component\n * has to have the primary and aux outlets defined.\n *\n * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into\n * the `params`, `data`, and `resolve` of the children. This is done because there is no component\n * that can inject the activated route of the componentless parent.\n *\n * This is especially useful when child components are defined as follows:\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * With this configuration in place, navigating to '/parent/10' will create the main child and aux\n * components.\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up our application load time by splitting it into multiple bundles, and\n * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of\n * providing the children property, you can provide\n * the loadChildren property, as follows:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   loadChildren: 'team'\n * }]\n * ```\n *\n * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.\n * Then it will\n * extract the set of routes defined in that NgModule, and will transparently add those routes to\n * the main configuration.\n *\n * @stable use Routes\n */\nexport type Routes = Route[];\n\n/**\n * @whatItDoes Represents the results of the URL matching.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @experimental\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[]; posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * @whatItDoes A function matching URLs\n *\n * @description\n *\n * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't\n * expressive enough.\n *\n * For instance, the following matcher matches html files.\n *\n * ```\n * function htmlFiles(url: UrlSegment[]) {\n *  return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * const routes = [{ matcher: htmlFiles, component: HtmlCmp }];\n * ```\n *\n * @experimental\n */\nexport type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) =>\n    UrlMatchResult;\n\n/**\n * @whatItDoes Represents the static data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes Represents the resolved data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes The type of `loadChildren`.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildrenCallback = () => Type<any>| Promise<Type<any>>| Observable<Type<any>>;\n\n/**\n * @whatItDoes The type of `loadChildren`.\n *\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildren = string | LoadChildrenCallback;\n\n/**\n * See {@link Routes} for more details.\n * @stable\n */\nexport interface Route {\n  path?: string;\n  pathMatch?: string;\n  matcher?: UrlMatcher;\n  component?: Type<any>;\n  redirectTo?: string;\n  outlet?: string;\n  canActivate?: any[];\n  canActivateChild?: any[];\n  canDeactivate?: any[];\n  canLoad?: any[];\n  data?: Data;\n  resolve?: ResolveData;\n  children?: Route[];\n  loadChildren?: LoadChildren;\n}\n\nexport function validateConfig(config: Routes): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    validateNode(config[i]);\n  }\n}\n\nfunction validateNode(route: Route): void {\n  if (!route) {\n    throw new Error(`\n      Invalid route configuration: Encountered undefined route.\n      The reason might be an extra comma.\n       \n      Example: \n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n  }\n  if (Array.isArray(route)) {\n    throw new Error(`Invalid route configuration: Array cannot be specified`);\n  }\n  if (route.component === undefined && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n    throw new Error(\n        `Invalid route configuration of route '${route.path}': a componentless route cannot have a named outlet set`);\n  }\n  if (!!route.redirectTo && !!route.children) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': redirectTo and children cannot be used together`);\n  }\n  if (!!route.redirectTo && !!route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': redirectTo and loadChildren cannot be used together`);\n  }\n  if (!!route.children && !!route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': children and loadChildren cannot be used together`);\n  }\n  if (!!route.redirectTo && !!route.component) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': redirectTo and component cannot be used together`);\n  }\n  if (!!route.path && !!route.matcher) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': path and matcher cannot be used together`);\n  }\n  if (route.redirectTo === undefined && !route.component && !route.children &&\n      !route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': one of the following must be provided (component or redirectTo or children or loadChildren)`);\n  }\n  if (route.path === undefined) {\n    throw new Error(`Invalid route configuration: routes must have path specified`);\n  }\n  if (route.path.startsWith('/')) {\n    throw new Error(\n        `Invalid route configuration of route '${route.path}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== undefined && route.pathMatch === undefined) {\n    const exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid route configuration of route '{path: \"${route.path}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n  if (route.pathMatch !== undefined && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': pathMatch can only be set to 'prefix' or 'full'`);\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}