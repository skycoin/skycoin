{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../../modules/@angular/forms/src/validators.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OpaqueToken} from '@angular/core';\nimport {toPromise} from 'rxjs/operator/toPromise';\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {StringMapWrapper} from './facade/collection';\nimport {isPresent} from './facade/lang';\nimport {AbstractControl} from './model';\nimport {isPromise} from './private_import_core';\n\nfunction isEmptyInputValue(value: any) {\n  return value == null || typeof value === 'string' && value.length === 0;\n}\n\n/**\n * Providers for validators to be used for {@link FormControl}s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n * @stable\n */\nexport const NG_VALIDATORS: OpaqueToken = new OpaqueToken('NgValidators');\n\n/**\n * Providers for asynchronous validators to be used for {@link FormControl}s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See {@link NG_VALIDATORS} for more details.\n *\n * @stable\n */\nexport const NG_ASYNC_VALIDATORS: OpaqueToken = new OpaqueToken('NgAsyncValidators');\n\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a {@link FormControl} or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new FormControl(\"\", Validators.required)\n * ```\n *\n * @stable\n */\nexport class Validators {\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control: AbstractControl): {[key: string]: boolean} {\n    return isEmptyInputValue(control.value) ? {'required': true} : null;\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const length = typeof control.value === 'string' ? control.value.length : 0;\n      return length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      const length = typeof control.value === 'string' ? control.value.length : 0;\n      return length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    if (!pattern) return Validators.nullValidator;\n    let regex: RegExp;\n    let regexStr: string;\n    if (typeof pattern === 'string') {\n      regexStr = `^${pattern}$`;\n      regex = new RegExp(regexStr);\n    } else {\n      regexStr = pattern.toString();\n      regex = pattern;\n    }\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value: string = control.value;\n      return regex.test(value) ? null :\n                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n    };\n  }\n\n  /**\n   * No-op validator.\n   */\n  static nullValidator(c: AbstractControl): {[key: string]: boolean} { return null; }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   */\n  static compose(validators: ValidatorFn[]): ValidatorFn {\n    if (!validators) return null;\n    const presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  static composeAsync(validators: AsyncValidatorFn[]): AsyncValidatorFn {\n    if (!validators) return null;\n    const presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      const promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n      return Promise.all(promises).then(_mergeErrors);\n    };\n  }\n}\n\nfunction _convertToPromise(obj: any): Promise<any> {\n  return isPromise(obj) ? obj : toPromise.call(obj);\n}\n\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: any[]): {[key: string]: any} {\n  const res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: {[key: string]: any}, errors: {[key: string]: any}) => {\n        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n      }, {});\n  return Object.keys(res).length === 0 ? null : res;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}