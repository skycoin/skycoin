{"version":3,"file":"element_ref.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/linker/element_ref.ts"],"names":[],"mappings":";AAIE;;;;;EAKC;AACH,2EAA2E;AAC3E,2FAA2F;AAC3F,6CAA6C;AAC7C;IAsBE,oBAAY,aAAkB;QAAI,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IAAC,CAAC;IACzE,iBAAC;AAAD,CAAC,AAvBD,IAuBC;AAvBY,kBAAU,aAuBtB,CAAA","sourcesContent":["interface DecoratorInvocation {\n    type: Function;\n    args?: any[];\n  }\n  /**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef {\n  /**\n   * The underlying native element or `null` if direct access to native elements is not supported\n   * (e.g. when the application runs in a web worker).\n   *\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}\n   *    which provides API that can safely be used even when direct access to native elements is not\n   *    supported.\n   *   </p>\n   *   <p>\n   *    Relying on direct DOM access creates tight coupling between your application and rendering\n   *    layers which will make it impossible to separate the two and deploy your application into a\n   *    web worker.\n   *   </p>\n   * </div>\n   */\n  public nativeElement: any;\n\n  constructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n"]}