{"version":3,"file":"router_outlet.js","sourceRoot":"","sources":["../../../../../../modules/@angular/router-deprecated/src/directives/router_outlet.ts"],"names":[],"mappings":"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","sourcesContent":["import {PromiseWrapper, EventEmitter} from '../../src/facade/async';\nimport {StringMapWrapper} from '../../src/facade/collection';\nimport {isBlank, isPresent} from '../../src/facade/lang';\nimport {\n  Directive,\n  Attribute,\n  DynamicComponentLoader,\n  ComponentRef,\n  ViewContainerRef,\n  provide,\n  ReflectiveInjector,\n  OnDestroy,\n  Output\n} from '@angular/core';\nimport * as routerMod from '../router';\nimport {ComponentInstruction, RouteParams, RouteData} from '../instruction';\nimport * as hookMod from '../lifecycle/lifecycle_annotations';\nimport {hasLifecycleHook} from '../lifecycle/route_lifecycle_reflector';\nimport {OnActivate, CanReuse, OnReuse, OnDeactivate, CanDeactivate} from '../interfaces';\n\nlet _resolveToTrue = PromiseWrapper.resolve(true);\n\n/**\n * A router outlet is a placeholder that Angular dynamically fills based on the application's route.\n *\n * ## Use\n *\n * ```\n * <router-outlet></router-outlet>\n * ```\n */\n@Directive({selector: 'router-outlet'})\nexport class RouterOutlet implements OnDestroy {\n  name: string = null;\n  private _componentRef: Promise<ComponentRef<any>> = null;\n  private _currentInstruction: ComponentInstruction = null;\n\n  @Output('activate') public activateEvents = new EventEmitter<any>();\n\n  constructor(private _viewContainerRef: ViewContainerRef, private _loader: DynamicComponentLoader,\n              private _parentRouter: routerMod.Router, @Attribute('name') nameAttr: string) {\n    if (isPresent(nameAttr)) {\n      this.name = nameAttr;\n      this._parentRouter.registerAuxOutlet(this);\n    } else {\n      this._parentRouter.registerPrimaryOutlet(this);\n    }\n  }\n\n  /**\n   * Called by the Router to instantiate a new component during the commit phase of a navigation.\n   * This method in turn is responsible for calling the `routerOnActivate` hook of its child.\n   */\n  activate(nextInstruction: ComponentInstruction): Promise<any> {\n    var previousInstruction = this._currentInstruction;\n    this._currentInstruction = nextInstruction;\n    var componentType = nextInstruction.componentType;\n    var childRouter = this._parentRouter.childRouter(componentType);\n\n    var providers = ReflectiveInjector.resolve([\n      provide(RouteData, {useValue: nextInstruction.routeData}),\n      provide(RouteParams, {useValue: new RouteParams(nextInstruction.params)}),\n      provide(routerMod.Router, {useValue: childRouter})\n    ]);\n    this._componentRef =\n        this._loader.loadNextToLocation(componentType, this._viewContainerRef, providers);\n    return this._componentRef.then((componentRef) => {\n      this.activateEvents.emit(componentRef.instance);\n      if (hasLifecycleHook(hookMod.routerOnActivate, componentType)) {\n        return this._componentRef.then(\n            (ref: ComponentRef<any>) =>\n                (<OnActivate>ref.instance).routerOnActivate(nextInstruction, previousInstruction));\n      } else {\n        return componentRef;\n      }\n    });\n  }\n\n  /**\n   * Called by the {@link Router} during the commit phase of a navigation when an outlet\n   * reuses a component between different routes.\n   * This method in turn is responsible for calling the `routerOnReuse` hook of its child.\n   */\n  reuse(nextInstruction: ComponentInstruction): Promise<any> {\n    var previousInstruction = this._currentInstruction;\n    this._currentInstruction = nextInstruction;\n\n    // it's possible the component is removed before it can be reactivated (if nested withing\n    // another dynamically loaded component, for instance). In that case, we simply activate\n    // a new one.\n    if (isBlank(this._componentRef)) {\n      return this.activate(nextInstruction);\n    } else {\n      return PromiseWrapper.resolve(\n          hasLifecycleHook(hookMod.routerOnReuse, this._currentInstruction.componentType) ?\n              this._componentRef.then(\n                  (ref: ComponentRef<any>) =>\n                      (<OnReuse>ref.instance).routerOnReuse(nextInstruction, previousInstruction)) :\n              true);\n    }\n  }\n\n  /**\n   * Called by the {@link Router} when an outlet disposes of a component's contents.\n   * This method in turn is responsible for calling the `routerOnDeactivate` hook of its child.\n   */\n  deactivate(nextInstruction: ComponentInstruction): Promise<any> {\n    var next = _resolveToTrue;\n    if (isPresent(this._componentRef) && isPresent(this._currentInstruction) &&\n        hasLifecycleHook(hookMod.routerOnDeactivate, this._currentInstruction.componentType)) {\n      next = this._componentRef.then(\n          (ref: ComponentRef<any>) =>\n              (<OnDeactivate>ref.instance)\n                  .routerOnDeactivate(nextInstruction, this._currentInstruction));\n    }\n    return next.then((_) => {\n      if (isPresent(this._componentRef)) {\n        var onDispose = this._componentRef.then((ref: ComponentRef<any>) => ref.destroy());\n        this._componentRef = null;\n        return onDispose;\n      }\n    });\n  }\n\n  /**\n   * Called by the {@link Router} during recognition phase of a navigation.\n   *\n   * If this resolves to `false`, the given navigation is cancelled.\n   *\n   * This method delegates to the child component's `routerCanDeactivate` hook if it exists,\n   * and otherwise resolves to true.\n   */\n  routerCanDeactivate(nextInstruction: ComponentInstruction): Promise<boolean> {\n    if (isBlank(this._currentInstruction)) {\n      return _resolveToTrue;\n    }\n    if (hasLifecycleHook(hookMod.routerCanDeactivate, this._currentInstruction.componentType)) {\n      return this._componentRef.then(\n          (ref: ComponentRef<any>) =>\n              (<CanDeactivate>ref.instance)\n                  .routerCanDeactivate(nextInstruction, this._currentInstruction));\n    } else {\n      return _resolveToTrue;\n    }\n  }\n\n  /**\n   * Called by the {@link Router} during recognition phase of a navigation.\n   *\n   * If the new child component has a different Type than the existing child component,\n   * this will resolve to `false`. You can't reuse an old component when the new component\n   * is of a different Type.\n   *\n   * Otherwise, this method delegates to the child component's `routerCanReuse` hook if it exists,\n   * or resolves to true if the hook is not present.\n   */\n  routerCanReuse(nextInstruction: ComponentInstruction): Promise<boolean> {\n    var result;\n\n    if (isBlank(this._currentInstruction) ||\n        this._currentInstruction.componentType != nextInstruction.componentType) {\n      result = false;\n    } else if (hasLifecycleHook(hookMod.routerCanReuse, this._currentInstruction.componentType)) {\n      result = this._componentRef.then(\n          (ref: ComponentRef<any>) =>\n              (<CanReuse>ref.instance).routerCanReuse(nextInstruction, this._currentInstruction));\n    } else {\n      result = nextInstruction == this._currentInstruction ||\n               (isPresent(nextInstruction.params) && isPresent(this._currentInstruction.params) &&\n                StringMapWrapper.equals(nextInstruction.params, this._currentInstruction.params));\n    }\n    return <Promise<boolean>>PromiseWrapper.resolve(result);\n  }\n\n  ngOnDestroy(): void { this._parentRouter.unregisterPrimaryOutlet(this); }\n}\n"]}