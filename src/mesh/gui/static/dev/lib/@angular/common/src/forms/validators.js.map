{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../../../modules/@angular/common/src/forms/validators.ts"],"names":[],"mappings":"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","sourcesContent":["interface DecoratorInvocation {\n    type: Function;\n    args?: any[];\n  }\n  import {OpaqueToken} from '@angular/core';\n\nimport {isBlank, isPresent, isString} from '../../src/facade/lang';\nimport {PromiseWrapper} from '../../src/facade/promise';\nimport {ObservableWrapper} from '../../src/facade/async';\nimport {StringMapWrapper} from '../../src/facade/collection';\nimport * as modelModule from './model';\nimport {ValidatorFn, AsyncValidatorFn} from './directives/validators';\n\n/**\n * Providers for validators to be used for {@link Control}s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n */\nexport const NG_VALIDATORS: OpaqueToken = /*@ts2dart_const*/ new OpaqueToken(\"NgValidators\");\n\n/**\n * Providers for asynchronous validators to be used for {@link Control}s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See {@link NG_VALIDATORS} for more details.\n */\nexport const NG_ASYNC_VALIDATORS: OpaqueToken =\n    /*@ts2dart_const*/ new OpaqueToken(\"NgAsyncValidators\");\n\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a {@link Control} or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new Control(\"\", Validators.required)\n * ```\n */\nexport class Validators {\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control: modelModule.AbstractControl): {[key: string]: boolean} {\n    return isBlank(control.value) || (isString(control.value) && control.value == \"\") ?\n               {\"required\": true} :\n               null;\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: modelModule.AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      var v: string = control.value;\n      return v.length < minLength ?\n                 {\"minlength\": {\"requiredLength\": minLength, \"actualLength\": v.length}} :\n                 null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: modelModule.AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      var v: string = control.value;\n      return v.length > maxLength ?\n                 {\"maxlength\": {\"requiredLength\": maxLength, \"actualLength\": v.length}} :\n                 null;\n    };\n  }\n\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern: string): ValidatorFn {\n    return (control: modelModule.AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      let regex = new RegExp(`^${pattern}$`);\n      let v: string = control.value;\n      return regex.test(v) ? null :\n                             {\"pattern\": {\"requiredPattern\": `^${pattern}$`, \"actualValue\": v}};\n    };\n  }\n\n  /**\n   * No-op validator.\n   */\n  static nullValidator(c: modelModule.AbstractControl): {[key: string]: boolean} { return null; }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   */\n  static compose(validators: ValidatorFn[]): ValidatorFn {\n    if (isBlank(validators)) return null;\n    var presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: modelModule.AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  static composeAsync(validators: AsyncValidatorFn[]): AsyncValidatorFn {\n    if (isBlank(validators)) return null;\n    var presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: modelModule.AbstractControl) {\n      let promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n      return PromiseWrapper.all(promises).then(_mergeErrors);\n    };\n  }\n}\n\nfunction _convertToPromise(obj: any): any {\n  return PromiseWrapper.isPromise(obj) ? obj : ObservableWrapper.toPromise(obj);\n}\n\nfunction _executeValidators(control: modelModule.AbstractControl,\n                            validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: modelModule.AbstractControl,\n                                 validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: any[]): {[key: string]: any} {\n  var res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: {[key: string]: any}, errors: {[key: string]: any}) => {\n        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n      }, {});\n  return StringMapWrapper.isEmpty(res) ? null : res;\n}\n"]}