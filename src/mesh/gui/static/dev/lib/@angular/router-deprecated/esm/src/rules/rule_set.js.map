{"version":3,"file":"rule_set.js","sourceRoot":"","sources":["../../../../../../modules/@angular/router-deprecated/src/rules/rule_set.ts"],"names":[],"mappings":"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","sourcesContent":["import {isBlank, isPresent, isFunction} from '../../src/facade/lang';\nimport {BaseException} from '../../src/facade/exceptions';\nimport {Map} from '../../src/facade/collection';\nimport {PromiseWrapper} from '../../src/facade/async';\nimport {AbstractRule, RouteRule, RedirectRule, RouteMatch, PathMatch} from './rules';\nimport {\n  Route,\n  AsyncRoute,\n  AuxRoute,\n  Redirect,\n  RouteDefinition\n} from '../route_config/route_config_impl';\nimport {AsyncRouteHandler} from './route_handlers/async_route_handler';\nimport {SyncRouteHandler} from './route_handlers/sync_route_handler';\nimport {RoutePath} from './route_paths/route_path';\nimport {ParamRoutePath} from './route_paths/param_route_path';\nimport {RegexRoutePath} from './route_paths/regex_route_path';\nimport {Url} from '../url_parser';\nimport {ComponentInstruction} from '../instruction';\n\n\n/**\n * A `RuleSet` is responsible for recognizing routes for a particular component.\n * It is consumed by `RouteRegistry`, which knows how to recognize an entire hierarchy of\n * components.\n */\nexport class RuleSet {\n  rulesByName = new Map<string, RouteRule>();\n\n  // map from name to rule\n  auxRulesByName = new Map<string, RouteRule>();\n\n  // map from starting path to rule\n  auxRulesByPath = new Map<string, RouteRule>();\n\n  // TODO: optimize this into a trie\n  rules: AbstractRule[] = [];\n\n  // the rule to use automatically when recognizing or generating from this rule set\n  defaultRule: RouteRule = null;\n\n  /**\n   * Configure additional rules in this rule set from a route definition\n   * @returns {boolean} true if the config is terminal\n   */\n  config(config: RouteDefinition): boolean {\n    let handler;\n\n    if (isPresent(config.name) && config.name[0].toUpperCase() != config.name[0]) {\n      let suggestedName = config.name[0].toUpperCase() + config.name.substring(1);\n      throw new BaseException(\n          `Route \"${config.path}\" with name \"${config.name}\" does not begin with an uppercase letter. Route names should be CamelCase like \"${suggestedName}\".`);\n    }\n\n    if (config instanceof AuxRoute) {\n      handler = new SyncRouteHandler(config.component, config.data);\n      let routePath = this._getRoutePath(config);\n      let auxRule = new RouteRule(routePath, handler, config.name);\n      this.auxRulesByPath.set(routePath.toString(), auxRule);\n      if (isPresent(config.name)) {\n        this.auxRulesByName.set(config.name, auxRule);\n      }\n      return auxRule.terminal;\n    }\n\n    let useAsDefault = false;\n\n    if (config instanceof Redirect) {\n      let routePath = this._getRoutePath(config);\n      let redirector = new RedirectRule(routePath, config.redirectTo);\n      this._assertNoHashCollision(redirector.hash, config.path);\n      this.rules.push(redirector);\n      return true;\n    }\n\n    if (config instanceof Route) {\n      handler = new SyncRouteHandler(config.component, config.data);\n      useAsDefault = isPresent(config.useAsDefault) && config.useAsDefault;\n    } else if (config instanceof AsyncRoute) {\n      handler = new AsyncRouteHandler(config.loader, config.data);\n      useAsDefault = isPresent(config.useAsDefault) && config.useAsDefault;\n    }\n    let routePath = this._getRoutePath(config);\n    let newRule = new RouteRule(routePath, handler, config.name);\n\n    this._assertNoHashCollision(newRule.hash, config.path);\n\n    if (useAsDefault) {\n      if (isPresent(this.defaultRule)) {\n        throw new BaseException(`Only one route can be default`);\n      }\n      this.defaultRule = newRule;\n    }\n\n    this.rules.push(newRule);\n    if (isPresent(config.name)) {\n      this.rulesByName.set(config.name, newRule);\n    }\n    return newRule.terminal;\n  }\n\n\n  /**\n   * Given a URL, returns a list of `RouteMatch`es, which are partial recognitions for some route.\n   */\n  recognize(urlParse: Url): Promise<RouteMatch>[] {\n    var solutions = [];\n\n    this.rules.forEach((routeRecognizer: AbstractRule) => {\n      var pathMatch = routeRecognizer.recognize(urlParse);\n\n      if (isPresent(pathMatch)) {\n        solutions.push(pathMatch);\n      }\n    });\n\n    // handle cases where we are routing just to an aux route\n    if (solutions.length == 0 && isPresent(urlParse) && urlParse.auxiliary.length > 0) {\n      return [PromiseWrapper.resolve(new PathMatch(null, null, urlParse.auxiliary))];\n    }\n\n    return solutions;\n  }\n\n  recognizeAuxiliary(urlParse: Url): Promise<RouteMatch>[] {\n    var routeRecognizer: RouteRule = this.auxRulesByPath.get(urlParse.path);\n    if (isPresent(routeRecognizer)) {\n      return [routeRecognizer.recognize(urlParse)];\n    }\n\n    return [PromiseWrapper.resolve(null)];\n  }\n\n  hasRoute(name: string): boolean { return this.rulesByName.has(name); }\n\n  componentLoaded(name: string): boolean {\n    return this.hasRoute(name) && isPresent(this.rulesByName.get(name).handler.componentType);\n  }\n\n  loadComponent(name: string): Promise<any> {\n    return this.rulesByName.get(name).handler.resolveComponentType();\n  }\n\n  generate(name: string, params: any): ComponentInstruction {\n    var rule: RouteRule = this.rulesByName.get(name);\n    if (isBlank(rule)) {\n      return null;\n    }\n    return rule.generate(params);\n  }\n\n  generateAuxiliary(name: string, params: any): ComponentInstruction {\n    var rule: RouteRule = this.auxRulesByName.get(name);\n    if (isBlank(rule)) {\n      return null;\n    }\n    return rule.generate(params);\n  }\n\n  private _assertNoHashCollision(hash: string, path) {\n    this.rules.forEach((rule) => {\n      if (hash == rule.hash) {\n        throw new BaseException(\n            `Configuration '${path}' conflicts with existing route '${rule.path}'`);\n      }\n    });\n  }\n\n  private _getRoutePath(config: RouteDefinition): RoutePath {\n    if (isPresent(config.regex)) {\n      if (isFunction(config.serializer)) {\n        return new RegexRoutePath(config.regex, config.serializer);\n      } else {\n        throw new BaseException(\n            `Route provides a regex property, '${config.regex}', but no serializer property`);\n      }\n    }\n    if (isPresent(config.path)) {\n      // Auxiliary routes do not have a slash at the start\n      let path = (config instanceof AuxRoute && config.path.startsWith('/')) ?\n                     config.path.substring(1) :\n                     config.path;\n      return new ParamRoutePath(path);\n    }\n    throw new BaseException('Route must provide either a path or regex property');\n  }\n}\n"]}